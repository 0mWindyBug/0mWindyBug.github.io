---
title:  "Windows Filtering Platform internals - Reverse Engineering the callout mechanism"
date:   2025-06-28
tags: [posts]
excerpt: "Reversing the WFP callout mechanism"
---

## Intro
The Windows Filtering Platform (WFP) is a framework designated for host-based network traffic filtering, replacing the older NDIS and TDI filtering capabilities. WFP exposes both UM and KM apis, offering the ability to block, permit or aduit network traffic based on conditions or deep packet inspection (through "callouts"). As you might have guessed, WFP is leveraged by the Windows Firewall, Network filters of security products and even rootkits. This blogpost is going to dive into how WFP callouts are managed by the kernel, and use our knowledge to suggest ways to evade components that leverage WFP. 

## The provided sources 
Before we jump right into it, about the blogpost's repo: 
`WFPEnumUM` and `WFPEnumDriver` can be used to enumerate all registered callouts on the system (including their actual addresses, to use just load the driver and run the client). 
`WFPCalloutDriver` is a PoC callout driver (mainly used it for debugging but you can have a look to see the registration process) 

## Starting with the terminology 
There are four terms used heavily across the WFP documentation:
* Layers - used to categorize the type of network traffic to be evaluated, identified by a GUID and represent a location in the network processing stack. For example, you can attach on layer `FWPM_LAYER_INBOUND_TRANSPORT_V4` to filter packets just after their transport header has been parsed by the network stack, but before any additionl transport layer processing takes place. 

* Filters - Constructed from conditions (source port, ip etc...) and actions (permit, block, callout unknown, callout inspection and callout terminating). When the action is callout, and if the filter's conditions match, the filter engine will call the filter's registered driver callback, providing it with the opportunity to inspect the packet's content. A callout may return permit, block or continue. If the action is callout terminating, it may return only permit or block, if it's callout inspection - it should only return continue, and for callout unknown - the callout may act as terminating or not based on the result of the classification, there are no guarantees.  

* Sublayers - A way to logically group filters. Say you filter TCP traffic, and want to implement different filters for different ranges of ports, you can create two seperate sublayers for each range of ports.

* Shims - A kernel component responsible for initating the classification process. That is, applying the correct filters to the packet and enforce the resulting action. The shim is called by `tcpip.sys` for each layer a packet arrives to at the network stack:

![shimcallstack](https://github.com/0mWindyBug/WFPResearch/assets/139051196/f7007c83-2d52-48fb-8755-a6e29e08fff0)

## More terminology! 
Filter arbitration is the logic implemented in WFP to decide the relations between different filters operating on the same layers, and essentially how it all works together. What I mean is, some ordering must be applied when processing filters. So let's get familiar with a few more WFP terms:
* Weight - Each filter has an assocciated weight value which defines the filter's priority within a sublayer. Each sublayer has it's own weight to define it's priority within a layer. The shim processes an incoming packet by traversing sublayers from the one with the highest weight to the one with the lowest. A final decision is made only after all sublayers have been evaluated, allowing a multiple matching capability. 

* Filter arbitration - Refers to the process of constructing the list of matching filters ordered by weight and evaluating them until a either a filter returns permit or block, or until the list of filters is exausted. That is of course per sublayer. 

* Policy - As I said, within a layer all sublayers will be traversed regardless of whether a sublayer evaluated a deterministic action (e.g block, permit...). What if one sublayer returns `permit` and the other returns `block`? The final decision is based on a well defined policy:
  * Actions are evaluated from high priotiy sublayers to lower priority sublayers.
  * A block decision overrides a permit decision.
  * A block decision is final. The packet will be discarded.  




TBC
