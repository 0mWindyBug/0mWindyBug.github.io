---
title:  "Hands Up! Give Us the Stack! This Is a ROPpery!"
date:   2019-09-21
tags: [posts]
excerpt: "An introduction to utilizing Return Oriented Progamming to defeat Data Execution Prevention (DEP)"
---
Introduction
---
Over the years, the security community as a whole realized that there needed to be a way to stop exploit developers from easily executing malicious shellcode. Microsoft, over time, has implemented a plethora of intense exploit mitigations, such as: [EMET (the Enhanced Mitigation Experience Toolkit)](https://support.microsoft.com/en-us/help/2458544/the-enhanced-mitigation-experience-toolkit), [CFG (Control Flow Guard)](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard), [Windows Defender Exploit Guard](https://www.microsoft.com/security/blog/2017/10/23/windows-defender-exploit-guard-reduce-the-attack-surface-against-next-generation-malware/), and [ASLR (Address Space Layout Randomization)](https://docs.microsoft.com/en-us/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019).

[DEP](https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in), or Data Execution Prevention, is another one of those roadblocks that hinders exploit developers. This blog post will only focusing on defeating DEP, within a stack based data structure on Windows. 

A Brief Word About DEP
---
Windows XP SP2 32 bit was the first Windows operating system to ship DEP. Every version of Windows since then has included DEP. DEP, at a high level, gives memory two independent permission levels. They are:
- The ability to write to memory.

  __OR__

- The ability to execute memory.

But not both.

What this means, is that someone cannot write ___AND___ execute memory at the same time. This means a few things for exploit developers. Let's say you have a simple vanilla stack instruction pointer overwrite. Let's also say the first byte, and all of the following bytes of your payload, are pointed to by the stack pointer. Normally, a simple `jmp stack pointer` instruction would suffice- and it would rain shells. With DEP, it is not that simple. Since that shellcode is user introduced shellcode- you will be able to write to the stack. BUT, as soon as any execution of that user supplied shellcode is attempted- an access violation will occur, and the application will terminate.

DEP manifests itself in four different policy settings. From the MSDN documentation on DEP, here are the four policy settings:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP1.PNG" alt="">

Knowing the applicable information on how DEP is implemented, figuring how to defeat DEP is the next viable step.

Windows API, We Meet Again
---

In my [last post](https://connormcgarr.github.io/WS32_recv()-Reuse/), I explained and outlined how powerful the Windows API is. Microsoft has released all of the [documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) ono the Windows API, which aids in reverse engineering the parameters needed for API function calls.

Defeating DEP is no different. There are many API functions that can be used to defeat DEP. A few of them include:
- __[VirtualProtect()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)__
- __[VirtualAlloc()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)__
- __[WriteProcessMemory()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)__
- __[HeapCreate()](https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate)__

But the only limitation to defeating DEP, is the number of applicable APIs in Windows that change the permissions of the memory containing shellcode.

For this post, `VirtualProtect()` will be the Windows API function used for bypassing DEP.

`VirtualProtect` takes the following parameters:
```c
BOOL VirtualProtect(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flNewProtect,
  PDWORD lpflOldProtect
);
```

`lpAddress` = A pointer an address that describes the starting page of the region of pages whose access protection attributes are to be changed.

`dwSize` = The size of the region whose access protection attributes are to be changed, in bytes.

`flNewProtect` = The memory protection option. This parameter can be one of the memory protection constants. (`0x40` sets the permissions of the memory page to read, write, and execute.)

`lpflOldProtect` = A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. (This should be any address that already has write permissions.)

Now this is all great and fine, but there is a question one should be asking themselves. If it is not possible to write the parameters to the stack and also execute them, how will the function even get executed?

Let's ROP!
---
This is where Return Oriented Programming comes in. Even when DEP is enabled, it is still possible to perform operations on the stack such as `push`, `pop`, `add`, `sub`, etc.

"How is that so? I thought it was not possible to write and execute on the stack?" This is a question you also may be having. The way ROP works, is by utilizing pointers to instructions that already exist within an application.

Let's say there's an application called __vulnserver.exe__. Let's say there is a memory address of `0xDEADBEEF` that when viewed, contains the instruction `add esp, 0x100`. If this memory address got loaded into the instruction pointer, it would execute the command it points to. But nothing user supplied was written to the stack.

What this means for exploit developers, is this. If one is able to chain a set of memory addresses together, that all point to useful instructions already existing in an application/system- it might be possible to change the permissions of the memory pages containing malicious shellcode. Let's get into how this looks from a practicality/hands-on approach.

If you would like to follow along, I will be developing this exploit on a 32 bit Windows 7 virtual machine with ASLR disabled. The application I will be utilizing is [vulnserver.exe](https://github.com/stephenbradshaw/vulnserver).

A Brief Introduction to ROP Gadgets and ROP Chains
---

The reason why ROP is called Return Oriented Programming, is because each instruction is always followed by a `ret` instruction. Each `ASM + ret` instruction is known as a ROP gadget. Whenever these gadgets are loaded consecutively one after the other, this is known as a ROP chain.

The `ret` is probably the most important part of the chain. The reason the return instruction is needed is simple. Let's say you own the stack. Let's say you are able to load your whole ROP chain onto the stack. How would you execute it?

Enter `ret`. A return instruction simply takes whatever is located in the stack pointer (on top of the stack) and loads it into the instruction pointer (what is currently being executed). Since the ROP chain is located on the stack and a ROP chain is simply a bunch of memory addresses, the `ret` instruction will simply return to the stack, pick up the next memory address (ROP gadget), and execute it. This will keep happening, until there are no more left! This makes life a bit easier.

POC
---

Enough jibber jabber- here is the POC for `vulnserver.exe`:
```python
import struct
import sys
import os
import socket

# Vulnerable command
command = "TRUN ."

# 2006 byte offset to EIP
crash = "\x41" * 2006

# Stack Pivot (returning to the stack without a jmp/call)
crash += struct.pack('<L', 0x62501022)    # ret essfunc.dll

# 5000 byte total crash
filler = "\x43" * (5000-len(command)-len(crash))
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.235.130", 9999))
s.send(command+crash+filler)
s.close()
```

..But ...But What About Jumping to ESP?
---

There will not be a `jmp esp` instruction here. Remember, with DEP- this will kill the exploit. Instead, you'll need to find any memory address that contains a `ret` instruction. As outlined as above, this will directly take us back to the stack. This is normally called a _stack pivot_.

Where Art Thou ROP Gadgets?
---

The tool that will be used to find ROP gadgets is [rp++](https://github.com/0vercl0k/rp/downloads). Some other options are to use [mona.py](https://github.com/corelan/mona) or to search manually. To search manually all one would need to do is locate all instances of `ret` and look at the above instructions to see if there is anything useful. Mona will also construct a ROP chain for you that can be used to defeat DEP. This is not the point of this post. The point of this post, is that we are going to manually ROP the `vulnserver.exe` program. Only by manually doing something first, are you able to learn.

Here are all of the dependencies that make up `vulnserver.exe`. Execute the following `mona.py` command in [Immunity Debugger](https://debugger.immunityinc.com/ID_register.py):

`!mona modules`:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP2.PNG" alt="">

Next, us `rp++` to enumerate all useful ROP gadgets for all of the dependencies. Here is an example for `vulnserver.exe`. Run `rp++` for each dependency:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP3.PNG" alt="">


