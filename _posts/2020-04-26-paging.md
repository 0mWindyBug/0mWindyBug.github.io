---
title:  "(UNDER CONSTRUCTION) Turning the Pages: Introduction to Memory Paging on Windows 10 x64"
date:   2020-04-26
tags: [posts]
excerpt: "Brief introduction to memory paging on Windows 10 x64 to help leverage bypassing SMEP via page table entries."
---
Introduction
---

`0xFFFFFFFF11223344` is an example of a virtual memory address, and anyone who spends a lot of time inside of a debugger may be familiar with this notion. "Oh, that address is somewhere in memory and references X" may be an inference that is made about a virtual memory address. I always wondered where this address schema came from. It wasn't until I started doing research into kernel mode mitigation bypasses that I realized learning where these virtual addresses originate from is a very important concept. This blog will by no means serve as a complete guide to virtual and physical memory in Windows, as it could _EASILY_ be a multi series blog post. This blog is meant to serve as the prerequisite knowledge needed to do things like change permissions of a memory page in kernel mode with a vulnerability such as a write-what-where bug to bypass kernel mitigations such as SMEP or NonPagedPoolNx through page table entries. 

Let's dive into memory paging, and see where these virtual memory addresses originate from and what we can learn from these seemingly obscured 8 bytes we stubmle accross so copiously.

Firstly, before we begin, if you want a full fledged low level explanation of nearly every aspect of memory in Windows (which far surpasses the scope of this blog post) I _HIGHLY_ suggest reading [_What Makes It Page?: The Windows 7 (x64) Virtual Memory Manager_](https://www.amazon.com/What-Makes-Page-Windows-Virtual/dp/1479114294) written by Enrico Martignetti. In addition to paging, we will look at some ways we can use WinDbg to automate some of the more admittedly cumbersome steps in the memory paging process.

Paging? ELI5?
---

Memory paging refers to the implementation of virtual memory by the MMU (memory management unit). Virtual memory is mapped to physical memory, known as RAM (and in some cases, actually to disk temporarily if physical memory needs to be optimized elsewhere). 

One of the main reasons that memory paging is generally enabled, is the concept of "resource sharing". For instance, if we have two instances of the `calc.exe`- these two instances can share physical memory. Sharing physical memory is very important, as RAM is an expensive resource.

Take a look at the below image, from the [_Windows Internals, Part 1 (Developer Reference) 7th Edition_](https://www.amazon.com/Windows-Internals-Part-architecture-management/dp/0735684189) book to get a better understanding visually of virtual to physical memory mapping.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_1.png" alt="">

In addition to this information, it is important to note that a physical memory page is generally 4 KB (2 MB and even 1 GB pages can be addressed, but that is beyond the scope of this blog) in size on x64 Windows. We will see how this comes to fruition in upcoming sections of this post.

Before diving straight in to some of the lower level details, it is important to note there are a few different "paging modes" that can be utilized. Paging modes refer to the way paging is executed. The paging mode we will be referring to and using (as is default on _basically_ every x64 version of Windows) is Long-Mode Paging.

Are We There Yet?
---

If we want to understanding _WHAT_ paging actually does, let's take a look a moment and analyze how paging is actually enabled! Looking at some of the control registers will show us if/how paging is enabled and what paging mode are we using. 

According to the [_Intel 64 and IA-32 Architectures Software Developer's Manual_](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf), the CR0 register is responsible for paging being enabled.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_1a.png" alt="">

CR0.PG refers to the 31st bit of the CR0 register. If this bit is set to 1, paging is enabled. If it is set to 0, paging is disabled.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_1aa.png" alt="">

The above image is from a default installation of Windows 10 x64, showing the 31st bit of the CR0 bit is set to 1.

We now know that paging is enabled based on the image above- but what _kind_ of paging are we using? Referring again to the Intel manual, we notice that the CR4 control register is responsible for implementing the paging mode we are using.

As mentioned previously, the paging mode we are using is called Long-Mode Paging. Long-Mode Paging is another way of saying that Physical Address Extension, or PAE, is enabled. PAE enables 64-bit paging. If PAE was disabled, only 32-bit paging would be possible.

The 5th bit of the CR4 register is responsible for PAE being enabled. 1 = enabled, 0 = disabled.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_1b.png" alt="">

We can also see, on a default installation of Windows 10 x64, PAE is enabled by default.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_1cc.png" alt="">

Now that we know how to identify _IF_ and _WHAT KIND_ of paging is enabled, let's get into virtual to physical address translation!

Let's Get Physical!
---

The easiest way to think about a virtual memory address, and where it comes from, is to look at it from a different perspective. Don't take it at face value. Understanding what the virtual address is trying to accomplish, will surely shed some light on this whole process.

A virtual address is simply a computation of various indexes into several paging structures used to fetch the corresponding physical page to a virtual page, plus some "control bits". We will talk about control bits a bit later in this blog post.

Take a look at the image below, taken from the [_AMD64 Architecture Programmer's Manual Volume 2_](https://www.amd.com/system/files/TechDocs/24593.pdf).

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_2.png" alt="">

Although this image above looks very intimidating, let's break it down.

As we can see, the virtual address in this case is a 64-bit virtual address. The first portion of the address, bits 63-48, are represented as "__Sign Extend__". Let's leave this on the back burner for the time being.

We can see there are four paging structures in use:

1. Page-Map Level-4 Table (PML4)
2. Page-Directory-Pointer Table (PDPT)
3. Page-Directory Table (PDT)
4. Page Table (PT)

After bit 48, each 8 bits of a virtual address (47-39, 38-30, 29-21, 20-12, 11-0) are actually just indexing various paging structure tables. Note that "indexing" just refers to accessing each paging structure, and reading in/extracting whatever contents are needed.

Each one of these paging structure tables contains 512 page table entries, although the size of each entry depends on the paging structure.

So in totality, each paging structure is really a table with 512 entries each.

What will happen is, for each physical memory page the MMU wants to attribute to a virtual memory page, the MMU will access an entry from each table (a page table entry) that will "lead us" to a final 4 KB physical page (more on this later). Think of it as needing to pick a specific entry from each table to reach our final 4 KB physical memory page. We will get into some very high level mathematical computations on how this is done later, and seeing the exact anatomy of a virtual address in WinDbg. 

Now that we have some high level understanding of the various paging structures, and before diving into the paging structures and the CR3 register (PML4, I am looking at you)- let's circle back to bits 63-48, which are represented as "__Sign Extend__"

Canonical Addressing
---

In a 64-bit architecture, each virtual memory address has a total of 8 bytes, compared to a 4 byte x86 virtual memory address.

Referring back to the above section, we can recall that bits 63-48 are not accessing any paging structures. What is the purpose of this? It has to do with the limitations of the MMU.

Technically, a 64-bit system only uses 48 bits of its total power. This is because if a 64-bit system allowed all 64 bits to be addressed, the system would need to be able to address 16 exabytes of total virtual memory. 1 exabyte is equivalent to 1000000 terabytes (TB). The MMU would not be able to keep track of all of this from a translations perspective firstly (efficiently), and secondly (and most importantly) systems today cannot support this much virtual memory.

The CPU implements a "governor" of sorts, which limit 64-bit addresses to a 48-bit address. An address in which bits 63-47 are sign extended is known as a Caconical Address.

Sign extending bits 63-47 limits the virtual address space to 256 TB of RAM. This is still a lot, but it is still feasible.

Let's take a look to see how this all breaks down.

Referencing the Intel manual again, sign extending occurs in the following manner. Bit 47 is responsible for what bits 63-47 will be set to. 

If bit 47 is set to 0, bits 63-48 will also be set to 0. If bit 47 is set to 1, bits 63-48 will be set to 1 (resulting in hexadecimal F's in the virtual address).

The below chart, from [Intel](https://software.intel.com/en-us/articles/introduction-to-x64-assembly) shows what addresses are valid and what addresses are invalid, in accordance with canonical addressing and sign extending. NOte that we are only interested in the 48-bit addressing chart. 56-bit addressing refers to level 5 paging and 64-bit addressing refers to using the whol 64-bit address space.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_3aa.png" alt="">

Let's look at two examples below.

The first example is the address `KERNELBASE!VirtualProtect` which has a virtual memory address of `00007ffce032cfc0`. Breaking the address down into binary, we can see bit 47 is set to 0. Subsequently, bits 63-48 are also set to 0.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_4.png" alt="">

Generally, user mode addresses are going to be sign extended with a 0.

Taking a look at a kernel mode address, `nt!MiGetPteAddress`, we can see in this case bit 47 is set to 1. Meaning, bits 63-48 are also set to 1, resulting in all hexadecimal F's occuring in the virtual address as seen below.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_5aaaaa.png" alt="">

Now that we see how addressing is limited, let's get into the breakdown of a virtual address.

(_Note, question to you the reader. Now that we know 64-bit systems only utilize 48 bits, do you see a clear need for 128-bit processors in the near future?_)

The Anatomy of a Virtual Address (In All Its Glory)
---

Let's talk about paging structures and page table entries once again before we get into breaking down a virtual address.

Recall there are 4 main paging structures:

1. Page-Map Level-4 Table (PML4)
2. Page-Directory-Pointer Table (PDPT)
3. Page-Directory Table (PDT)
4. Page Table (PT)

As a point of contention, as well, when an entry for each of these tables is referenced it is as simple as tacking on an "E" to the end of each acronym. For instance, an entry from the PDT is known as a PDE. An entry from the PT is known as a PTE and so on.

Each one of these structures is a table that has 512 entries each. One PML4E can address up to 512 GB of memory. One PDPE can address 1 GB. One PDE can address 2 MB. Finally, one PTE can map 4 KB, or a physical memory page.

Note that the actual size of each entry is 8 bytes (the size of a virtual memory address in a 64-bit architecture).

Let's talk about the CR3 register for a moment, and its importance.

The CR3 register actually contains a _physical memory address_, which actually serves as the PML4 table base. This can be seen in the image below, where CR3 loads an actualy physical memory address.

<img src="{{ site.url }}{{ site.baseurl }}/images/PAGE_6.png" alt="">

This is how the paging process begins, as the PML4 can be fetched from the CR3 register.

There is one special thing to note, and that is the actual page table (PT).

Once the page table (PT) has been indexed in bits 20-12, bits 11-0 no longer need to fetch an index from any other paging structures. Bits 11-0 actually serve as an offset to a physical memory page 4 KB in size. Recall that an offset is the distance between two places (generally from a base, the PT in this case, to another location). Bits 11-0 simply serve as the actual distance from the page table base to the actual location of the physical memory. We will see this outlined very shortly when we perform a page translation in WinDbg.

Now that we understand at a bit of a lower level how each paging structure is indexed, let's take it a a lower level.
