---
title:  "Exploit Development: Rippity ROPpity The Stack Is Our Property - Blue Frost Security eko2019.exe Full ASLR and DEP Bypass on Windows 10 x64"
date:   2020-03-27
tags: [posts]
excerpt: "Reverse engineering BFS's eko2019.exe application and obtaining an ASLR bypass via an arbitrary read primitive."
---
Introduction
---
I recently have been spending the last few days working on obtaining some more experience with reverse engineering to complement my exploit development background. During this time, I stumbled across [this](https://labs.bluefrostsecurity.de/blog/2019/09/07/bfs-ekoparty-2019-exploitation-challenge/) challenge put on by Blue Frost Security earlier in the year- which requires both reverse engineering and exploit development skills. Although I would by no means consider myself an expert in reverse engineering, I decided this would be a nice way to try to become more well versed with the entire development lifecycle, starting with identifying vulnerabilities through reverse engineering to developing a functioning exploit.

Before we begin, I will be using using [Ghidra](https://ghidra-sre.org/) and [IDA Freeware 64-bit](https://www.hex-rays.com/products/ida/support/download_freeware/) to reverse the eko2019.exe application. In addition, I'll be using [WinDbg](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/) to develop the exploit. I prefer to use IDA to view the execution of a program- but I prefer to use the Ghidra decompiler to view the code that the program is comprised of. In addition to the aforementioned information, this exploit will be developed on Windows 10 x64 RS2, due to the fact the I already had a VM with this OS ready to go. This exploit will work up to Windows 10 x64 RS6 (1903 build), although the offsets between addresses will differ.

Reverse, Reverse!
---

Starting the application, we can clearly see the server has echoed some text into the command prompt where the server is running. 

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_1.png" alt="">

After some investigation, it seems this application binds to port 54321. Looking at the text in the command prompt window leads me to believe `printf()`, or similar functions, must have been called in order for the application to display this text. I am also inclined to believe that these print functions must be located somewhere around the routine that is responsible for opening up a socket on port 54321 and accepting messages. Let's crack open eko2019.exe in IDA and see if our hypothesis is correct.

By opening the __Strings__ subview in IDA, we can identify all of the strings within eko2019.exe.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_2a.png" alt="">

As we can see from the above image, we have identified a string that seems like a good place to start! `"[+] Message received: %i bytes\n"` is indicative that the server has received a connection and message from the client (us). The function/code that is responsible for incoming connections may be around where this string is located. By double-clicking on `.data:000000014000C0A8` (the address of this string), we can get a better look at the internals of the eko2019.exe application, as shown below.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_3a.png" alt="">

Perfect! We have identified where the string `"[+] Message received: %i bytes\n"` resides. In IDA, we have the ability to cross reference where a function, routine, instruction, etc. resides. This functionality is outlined by __DATA XREF: sub_1400011E0+11E↑o__, which is a cross reference of data in this case in the above image. If we double click on `sub_1400011E0+11E↑o` in the __DATA XREF__ comment, we will land on the function in which the `"[+] Message received: %i bytes\n"` string resides.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_4b.png" alt="">

Nice! As we can see from the above image, the place in which this string resides, is location (loc) `loc_1400012CA`. If we trace execution back to where it originated, we can see that the function we are inside is `sub_1400011E0` (eko2019.exe+0x11e0).

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_5.png" alt="">

After looking around this function for awhile, it is evident this is the function that handles connections and messages! Knowing this, let's head over to Ghidra and decompile this function to see what is going on.

Opening the function in Ghidra's decompiler, a few things stand out to us, as outlined in the image below.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_6.png" alt="">

Number one, The `local_258` variable is initialized with the `recv()` function. Using this function, eko2019.exe will "read in" the data sent from the client. The `recv()` function makes the function call with:
- A socket file descriptor, `param_1`, which is inherited from the `void FUN_1400011e0` function.
- A pointer to where the buffer that was received will be written to (`local_28`).
- The specified length which `local_28` should be (0x10 hexadecimal bytes/16 decimal bytes).
- Zero, which represents what flags should be implemented (none in this case).

What this means, is that the size of the request received by the `recv()` function will be stored in the variable `local_258`.

This is how the call looks, disassembled, within IDA.

<img src="{{ site.url }}{{ site.baseurl }}/images/BF_7a.png" alt="">

The next line of code after the value of `local_258` is set, makes a call to `printf()` which displays a message indicating the "header" has been received, and prints the value of `local_258`.

```c
printf(s__[+]_Header_received:_%i_bytes_14000c008,(ulonglong)local_258)
```

We can interpret this behavior, as that eko2019.exe seems to accept a header before the "message" portion of the client request is received. This header must be 0x10 hexadecimal bytes (16 decimal bytes) in length. This is the first "check" the application makes on our request, thus being the first "check" we must bypass.

Number two, after the header is received by the program, the specific variable that contains the pointer to the buffer received by the previous `recv()` request (`local_28`) is compared to the string constant `0x393130326f6b45`, or `Eko2019` in text form, in an `if` statement.

```c
if (local_28 == 0x393130326f6b45) {
```

Taking a look at the data type of the `local_28`, declared at the beginning of this function, we notice it is a `longlong`. This means that the variable should 8 bytes in totality. We notice, however, that `0x393130326f6b45` is only 7 bytes in length. This behavior is indicatory that the string of `Eko2019` should be null terminated. The null character will provide the last byte needed for our purposes.

This is how this check is executed, in IDA.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_8.png" alt="">

Number three, is the variable `local_20`'s size is compared to 0x201 (513 decimal).

```c
if (local_20 < 0x201) {
```

Where does this variable come from you ask? If we take a look two lines down, we can see that `local_20` is used in another `recv()` call, as the length of the buffer that stores the request.

```c
local_258 = recv(param_1,local_238,(uint)(ushort)local_20,0);
```

The `recv()` call here again uses the same type of parameters as the previous call and reuses the variable `local_528`. Let's take a look at the declaration of the variable `local_238` in the above `recv()` function call, as it hasn't been referenced in this blog post yet.

```c
char local_238 [512];
```

This allocates a buffer of 512 bytes. Looking at the above `recv()` call, here is how the parameters are lined up:
- A socket file descriptor, `param_1`, which is inherited from the `void FUN_1400011e0` function is used again.
- A pointer to where the buffer that was received will be written to (`local_238` this time, which is 512 bytes).
- The specified length, which is represented by `local_20`. This variable was used in the check implemented above, which looks to see if the size of the data recieved in the buffer is 512 bytes or less.
- Zero, which represents what flags should be implemented (none in this case).

The last check, looks to see if our message is sent in a multiple of 8 (aka aligned properly with a full 8 byte address). This check can be identified with relative ease.

```c
uVar2 = (int)local_258 >> 0x1f & 7;
if ((local_258 + uVar2 & 7) == uVar2) {
          iVar1 = printf(s__[+]_Remote_message_(%i):_'%s'_14000c0f8,(ulonglong)DAT_14000c000, local_238);
```

The size of `local_528`, which at this point is the size of our message (not the header), is shifted to the right, via the bitwise operator `>>`. This value is then bitwise AND'd with 7 decimal. This is what the result would look like, if our message size was 0x200 bytes (512 decimal), which is a known multiple of 8.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_9.png" alt="">

This value gets stored in the `uVar2` variable, which has a value of 0, based on the above photo.

If we would like our message to go through, it seems as though we are going to need to satisfy the above `if` statement. The `if` statement adds the value of `local_258` (presumably 0x200 in this example) to the value of `uVar2`, while using bitwise AND on the result of the addition with 7 decimal. If the total result is equal to `uVar2`, which is 0, the message is sent!

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_10.png" alt="">

As we can see, the statement `local_258 + uVar2 == uVar2` is indeed true, meaning we can send our message!

Let's try another scenario, with a value that is not a multiple of 8, like 0x199.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_11.png" alt="">

Using the same forumla above, with the bitwise shift right operator, we yield a value of 0.

Taking this value of 0, adding it to 0x199 and using bitwise AND on the result- yields a nonzero value (1).

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_12.png" alt="">

This means the `if` statement fails, and our message will not go through (since 0x199 is not a multiple of 8)!

In total, here are the checks we must bypass to send our buffer:

1. A 16 byte header (0x10 hexadecimal) with the string `0x393130326f6b45`, which is null terminated, as the first 8 bytes (remember, the first 16 bytes of the request are interpreted as the header. This means we need 8 additional bytes appended to the null terminated string).
2. Our message (not counting the header) must be 512 bytes (0x200 hexadecimal bytes) or less
3. Our message's length must be a multiple of 8 (the size of an x64 memory address)

Now that we have the ability to bypass the checks eko2019.exe makes on our buffer (which is comprised of the header and message), we can successfully interact with the server! The only question remains- where exactly does this buffer end up when it is received in the program? Let's take a look at the following snippet of code to find out.

```c
local_250[0] = FUNC_140001170
hProcess = GetCurrentProcess();
WriteProcessMemory(hProcess,FUN_140001000,local_250,8,&local_260);
```

The Windows API function `GetCurrentProcess()` first creates a handle to the current process (eko2019.exe). This handle is passed to a call to `WriteProcessMemory()`, which writes data to an area of memory in a specified process.

According [Microsoft Docs](https://docs.microsoft.com/en-us/) (formerly known as MSDN), a call to `WriteProcessMemory()` is defined as such.

```cpp
BOOL WriteProcessMemory(
  HANDLE  hProcess,
  LPVOID  lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesWritten
);
```

- `hProcess` in this case is will be set to the current process (eko2019.exe).
- `lpBaseAddress` is set to the function inside of eko2019.exe, `sub_140001000` (eko2019.exe+0x1000). This will be where `WriteProcessMemory()` starts writing memory to. 
- `lpBuffer` is where the memory written to `lpBaseAddress` will be taken from. In our case, the buffer will be taken from function `sub_140001170` (eko2019.exe+0x1170), which is represented by the variable `local_250`.
- `nSize` is statically assigned as a value of 8, this function call will write one QWORD.
- `*lpNumberOfBytesWritten` is a pointer to a variable that will receive the number of bytes written.

Now that we have better idea of what will be written where, let's see how this all looks in IDA.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_13.png" alt="">

There is something very interesting going on in the above image, that is not highlighted in red- but will be useful to some of the information outlined in red above. Namely, the following instructions.

```nasm
lea rcx, unk_14000E520
mov rcx, [rcx+rax*8]
call sub_140001170
```

If you can recall from the `WriteProcessMemory()` arguments, the buffer in which `WriteProcessMemory()` will write from, is actually from the function `sub_140001170`, which is eko2019.exe+0x1170 (via the `local_250` variable). From the above assembly code, we can see how and where this function is utilized! 

Looking at the assembly code, it seems as though the unkown data type, `unk_14000E520`, is placed into the RCX register. The value pointed to by this location (the actual data inside the unknown data type), with the value of RAX appended to it, is then placed fully into RCX. RCX is then passed to the call of the function `sub_140001170` (eko2019.exe+0x1170).

This function, `sub_140001170` (eko2019.exe+0x1170), will then return its value. The returned value of this function is going to be what is written to memory, via the `WriteProcessMemory()` function call.

We can recall from the `WriteProcessMemory()` function arguments earlier, that the location to which `sub_140001170` will be written to, is `sub_140001000` (eko2019.exe+0x1000). What is most interesting, is that this location is actually called directly after!

```nasm
call sub_140001000
```

Let's see what this function call looks in IDA.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_CALL.png" alt="">

Here, we verify that the value from RCX above (with RAX appended to it), is called here. Essentially, when `sub_140001000` (eko2019.exe+0x1000) is called after the `WriteProcessMemory()` routine, it will land on whatever the value the `sub_140001170` (eko2019.exe+0x1170) function returns, along with some NOPS and a return.

Can we leverage this functionality? Let's find out!

Stepping Stones
---

Now that we know what will be written to where, let's set a breakpoint on this location in memory in WinDbg, and start stepping through each instruction and dumping the contents of the registers in use. This will give us a clearer understanding of the behavior of eko2019.exe

Here is the proof of concept we will be using, based on the checks we have bypassed earlier.

```python
import sys
import os
import socket
import struct
import time

# Defining sleep shorthand
sleep = time.sleep

# 16 total bytes
print "[+] Sending the header..."
exploit = "\x45\x6B\x6F\x32\x30\x31\x39\x00" + "\x90"*8

# 512 bytes + 16 byte header = 528 total bytes
exploit += "\x41" * 512

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("172.16.55.132", 54321))
s.sendall(exploit)
s.recv(1024)
s.close()
```

Before sending this proof of concept, let's make sure a breakpoint is set at ek2010.exe+0x1330 (`sub_140001330`), as this is where we should hit, after our header is sent.

After sending our proof of concept, we can see we hit our breakpoint.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_14.png" alt="">

In addition to execution pausing, it seems as though we also control 0x1f8 bytes on the stack (504 decimal).

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_15.png" alt="">

Let's keep stepping through instructions, to see where we get!

After stepping through a few instructions, execution lands at this instruction, shown below.

```nasm 
lea rcx,[eko2019+0xe520 (00007ff6`6641e520)]
```

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_16.png" alt="">

This instruction loads the address of eko2019+0xe520 into RCX. Looking back, we recall this instruction came up earlier.

```nasm
lea rcx, unk_14000E520
mov rcx, [rcx+rax*8]
call sub_140001170
```

If we examine what is located at eko2019.exe+0xe520, we come across some interesting data, shown below.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_17.png" alt="">

It seems as though the value in RCX currently, is `00488b01c3c3c3c3`. This is very interesting, as we know that c3 bytes are that of a "return" instruction. What is of even more interest, is the first byte is set to zero. Since we know RAX is going to be appended to this value, it seems as though whatever is in RAX is going to complete this string! Let's step through the instruction that does this.

RAX is currently set to 0x3e

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_18.png" alt="">

The following instruction is executed, as shown below.

```nasm
mov rcx, [rcx+rax*8]
```

RCX now contains the value of RAX + RCX!

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_19.png" alt="">

Nice! This value is now going to be passed to the `sub_140001170` (eko2019.exe+0x1170) function. As we can see the function is ready to be executed, shown in the image below.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_20.png" alt="">

As we know, most of the time a function executes- the value it returns is placed in the accumulator register (RAX in this case). Take a look at the image below, which shows what value the `sub_140001170` (eko2019.exe+0x1170) function returns.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_22.png" alt="">

Interesting! It seems as though the call to `sub_140001170` (eko2019.exe+0x1170) inverted our bytes!

Based off of the research we have done previously, it is evident that this is QWORD that is going to be written to `sub_140001000` via the `WriteProcessMemory()` routine! 

As we can see below, the next item up for execution (that is of importance) is the `GetCurrentProcess()` routine, which will return a handle to the current process (eko2019.exe) into RAX, similarly to how the last function returned its value into RAX.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_23.png" alt="">

Taking a look into RAX, we can see a value of `ffffffffffffffff`. This represents the current process! For instance, if we wanted to call `WriteProcessMemory()` outside of a debugger in the C programming language for example, specifying the first function argument as `ffffffffffffffff` would represent the current process- without even needing to obtain a handle to the current process! This is because technically `GetCurrentProccess()` returns a "pseudo handle" to the current process. A pseudo handle is a special constant, which is -1, of `ffffffffffffffff`.

All that is left now, is to step through up until the call to `WriteProcessMemory()` to verify everything will write as expected.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_24.png" alt="">

Now that `WriteProcessMemory()` is about to be called- let's take a look at the parameters that will be used in the function call.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_26.png" alt="">

The fifth parameter is located at RSP + 0x20. This is what the `__fastcall` calling convention defaults to after four parameters. Each parameter after 5 will be located 8 bytes after RSP + 0x20, at RPS + 0x28, RSP + 0x32, etc.

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_27.png" alt="">

Awesome! As we can see from the above image, `WriteProcessMemory()` is going to write the value returned by `sub_140001170` (eko2019.exe+0x1170), which is located in the R8 register to the location of `sub_140001000` (eko2019+0x1000).

<img src="{{ site.url }}{{ site.baseurl }}/images/BFS_28.png" alt="">
